{"version":3,"file":"prouter.js","sourceRoot":"/source/","sources":["prouter.ts"],"names":["prouter","prouter.RouteHelper","prouter.RouteHelper.constructor","prouter.RouteHelper.parseQuery","prouter.RouteHelper.parsePath","prouter.RouteHelper.ensureSlashes","prouter.RouteHelper.escapeString","prouter.RouteHelper._escapeGroup","prouter.RouteHelper.clearSlashes","prouter.RouteHelper._flags","prouter.RouteHelper._parse","prouter.RouteHelper._tokensToPathExp","prouter.RouteHelper.stringToPathExp","prouter.Router","prouter.Router.constructor","prouter.Router.listen","prouter.Router.stop","prouter.Router.getCurrent","prouter.Router.use","prouter.Router.navigate","prouter.Router.heedCurrent","prouter.Router.load","prouter.Router.load.next","prouter.Router._extractHandlers","prouter.Router._obtainRequestProcessors","prouter.Router._extractRequest","prouter.RouteGroup","prouter.RouteGroup.constructor","prouter.RouteGroup.use"],"mappings":"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","sourcesContent":["/**\n * Unobtrusive, forward-thinking and lightweight JavaScript router library.\n */\nmodule prouter {\n\n    /**\n     * Contracts for static type checking.\n     */\n    export interface Options {\n        usePushState?: boolean;\n        hashChange?: boolean;\n        root?: string;\n        silent?: boolean;\n    }\n\n    export interface Path {\n        path: string;\n        query: Object;\n        queryString: string;\n    }\n\n    export interface PathExp extends RegExp {\n        keys?: PathExpToken[];\n    }\n\n    export interface PathExpToken {\n        name: string;\n        prefix: string;\n        delimiter: string;\n        optional: boolean;\n        repeat: boolean;\n        pattern: string;\n    }\n\n    export interface Handler {\n        pathExp: PathExp;\n        activate: Callback;\n    }\n\n    export interface GroupHandler {\n        path: any;\n        activate: Callback;\n    }\n\n    export interface Request extends Path {\n        params?: any;\n        oldPath?: string;\n    }\n\n    export interface RequestProcessor {\n        request: Request;\n        activate: Callback;\n    }\n\n    export interface Callback {\n      (req?: Request): any;\n    }\n\n    /** @type {global} Allow accessing the global var in the IDE, only required for TS compilation. */\n    declare const global: any;\n\n    /**\n     * Stablish the root object, `window` (`self`) in the browser, or `global` on the server.\n     * We use `self` instead of `window` for `WebWorker` support.\n     * @type {window} the root object\n     */\n    const _global = (typeof self === 'object' && self.self === self && self) ||\n        (typeof global === 'object' && global.global === global && global);\n\n    /** @type {RegExp} Cached regex for stripping out leading slashes. */\n    const LEADING_SLASHES_STRIPPER = /^\\/+|\\/+$/;\n\n    /**\n     * The main path matching regexp utility.\n     * @type {RegExp} path regexp.\n     */\n    const PATH_STRIPPER = new RegExp([\n    // Match escaped characters that would otherwise appear in future matches.\n    // This allows the user to escape special characters that won't transform.\n        '(\\\\\\\\.)',\n    // Match Express-style parameters and un-named parameters with a prefix\n    // and optional suffixes. Matches appear as:\n    //\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n    // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n        '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n    ].join('|'), 'g');\n\n    /** @type {RegExp} Cached regex for default route. */\n    const DEF_ROUTE = /.*/;\n\n    /** @type {Options} Default options for initializing the router. */\n    const DEF_OPTIONS: Options = { hashChange: true, usePushState: false, root: '/', silent: false };\n\n\n    /**\n     * Collection of helpers for processing routes.\n     * Most helpers of this class are sourced from https://github.com/pillarjs/path-to-regexp (used by Express also).\n     */\n    class RouteHelper {\n\n        /**\n         * Transform a query-string to an object.\n         * @param  {string} search The query string.\n         * @return {Object} The resulting object.\n         */\n        static parseQuery(queryString: string): Object {\n            const searchParams = {};\n            if (queryString.charAt(0) === '?') {\n                queryString = queryString.slice(1);\n            }\n            const paramsArr = queryString.split('&');\n            for (let i = 0; i < paramsArr.length; i++) {\n                const pair = paramsArr[i].split('=');\n                searchParams[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n            }\n            return searchParams;\n        }\n\n        /**\n         * Transform a fragment to a Path object.\n         * @param  {string} path The fragment to parse.\n         * @return {Path} The resulting object.\n         */\n        static parsePath(path: string): Path {\n\n            let parser: any;\n\n            if (typeof _global.URL === 'function') {\n                parser = new _global.URL(path, 'http://example.com');\n            } else {\n                parser = document.createElement('a');\n                parser.href = 'http://example.com/' + path;\n            }\n\n            const parsedPath: Path = {\n                path: RouteHelper.clearSlashes(parser.pathname),\n                query: RouteHelper.parseQuery(parser.search),\n                queryString: parser.search\n            };\n\n            return parsedPath;\n        }\n\n        /**\n         * Ensure the given string has leading slashes.\n         * @param  {string} str The string.\n         * @return {string} The string with leading slashes.\n         */\n        static ensureSlashes(str: string): string {\n            if (str === '/') {\n                return str;\n            }\n            if (str.charAt(0) !== '/') {\n                str = '/' + str;\n            }\n            if (str.charAt(str.length - 1) !== '/') {\n                str += '/';\n            }\n            return str;\n        }\n\n        /**\n         * Escape a regular expression string.\n         * @param  {String} str The string to scape\n         * @return {String} The escaped string\n         */\n        static escapeString(str: string): string {\n            return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1');\n        }\n\n        /**\n         * Escape the capturing group by escaping special characters and meaning.\n         * @param  {String} group The group to escape\n         * @return {String} The escaped group.\n         */\n        private static _escapeGroup(group: string): string {\n            return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n        }\n\n        /**\n         * Removes leading slashes from the given string.\n         * @param  {string} path The uri fragment.\n         * @return {string} The string without leading slashes.\n         */\n        static clearSlashes(path: string): string {\n            return path.replace(LEADING_SLASHES_STRIPPER, '');\n        }\n\n        /**\n         * Get the flags for a regexp from the options.\n         * @param  {Object} opts The options object for building the flags.\n         * @return {String} The flags.\n         */\n        private static _flags(opts: Object): string {\n            return opts['sensitive'] ? '' : 'i';\n        }\n\n        /**\n         * Parse a string for the raw tokens.\n         * @param  {String} path The fragment to pase.\n         * @return {Array} The tokens the extracted tokens.\n         */\n        private static _parse(path: string): any[] {\n\n            const tokens: any[] = [];\n            let key = 0;\n            let index = 0;\n            let pathIt = '';\n            let res: RegExpExecArray;\n\n            while ((res = PATH_STRIPPER.exec(path))) {\n\n                const m = res[0];\n                const escaped = res[1];\n                const offset = res.index;\n\n                pathIt += path.slice(index, offset);\n                index = offset + m.length;\n\n                // Ignore already escaped sequences.\n                if (escaped) {\n                    pathIt += escaped[1];\n                    continue;\n                }\n\n                // Push the current path onto the tokens.\n                if (pathIt) {\n                    tokens.push(pathIt);\n                    pathIt = '';\n                }\n\n                const prefix = res[2];\n                const name = res[3];\n                const capture = res[4];\n                const group = res[5];\n                const suffix = res[6];\n                const asterisk = res[7];\n\n                const repeat = suffix === '+' || suffix === '*';\n                const optional = suffix === '?' || suffix === '*';\n                const delimiter = prefix || '/';\n                const pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\n\n                tokens.push({\n                    name: name || (key++).toString(),\n                    prefix: prefix || '',\n                    delimiter: delimiter,\n                    optional: optional,\n                    repeat: repeat,\n                    pattern: RouteHelper._escapeGroup(pattern)\n                });\n            }\n\n            // Match any characters still remaining.\n            if (index < path.length) {\n                pathIt += path.substr(index);\n            }\n\n            // If the path exists, push it onto the end.\n            if (pathIt) {\n                tokens.push(pathIt);\n            }\n\n            return tokens;\n        }\n\n        /**\n         * Expose a function for taking tokens and returning a RegExp.\n         * @param  {Array} tokens The array of tokens used to create the expression.\n         * @param  {Object} [options] The configuration.\n         * @return {PathExp} The resulting path expression.\n         */\n        private static _tokensToPathExp(tokens: any[], options: Object = {}): PathExp {\n\n            const strict = options['strict'];\n            const end = options['end'] !== false;\n            let route = '';\n            const lastToken = tokens[tokens.length - 1];\n            const endsWithSlash = typeof lastToken === 'string' && lastToken.length && lastToken.charAt(lastToken.length - 1) === '/';\n\n            // Iterate over the tokens and create our regexp string.\n            for (let i = 0; i < tokens.length; i++) {\n\n                const token = tokens[i];\n\n                if (typeof token === 'string') {\n                    route += RouteHelper.escapeString(token);\n                } else {\n\n                    const prefix = RouteHelper.escapeString(token.prefix);\n                    let capture = token.pattern;\n\n                    if (token.repeat) {\n                        capture += '(?:' + prefix + capture + ')*';\n                    }\n\n                    if (token.optional) {\n                        if (prefix) {\n                            capture = '(?:' + prefix + '(' + capture + '))?';\n                        } else {\n                            capture = '(' + capture + ')?';\n                        }\n                    } else {\n                        capture = prefix + '(' + capture + ')';\n                    }\n\n                    route += capture;\n                }\n            }\n\n            // In non-strict mode we allow a slash at the end of match. If the path to\n            // match already ends with a slash, we remove it for consistency. The slash\n            // is valid at the end of a path match, not in the middle. This is important\n            // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n            if (!strict) {\n                route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\n            }\n\n            if (end) {\n                route += '$';\n            } else {\n                // In non-ending mode, we need the capturing groups to match as much as\n                // possible by using a positive lookahead to the end or next path segment.\n                route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\n            }\n\n            return new RegExp('^' + route, RouteHelper._flags(options));\n        }\n\n        /**\n         * Create a path regexp from string input.\n         * @param  {String} path The given url fragment.\n         * @param  {Object} [options] The configuration.\n         * @return {PathExp} The resulting path expression.\n         */\n        static stringToPathExp(path: string, options?: Object): PathExp {\n\n            const tokens = RouteHelper._parse(path);\n\n            const pathExp = RouteHelper._tokensToPathExp(tokens, options);\n\n            pathExp.keys = [];\n\n            // Attach keys back to the regexp.\n            for (let i = 0; i < tokens.length; i++) {\n                if (typeof tokens[i] !== 'string') {\n                    pathExp.keys.push(tokens[i]);\n                }\n            }\n\n            return pathExp;\n        }\n    }\n\n    /**\n     * Core component for the routing system.\n     */\n    export class Router {\n\n        /** @type {string} Root path. */\n        private static _root: string;\n        /** @type {Handler[]} Handlers for the routing system. */\n        private static _handlers: Handler[] = [];\n        /** @type {string} Last loaded path. */\n        private static _loadedPath: string;\n        /** @type {boolean} Is hashChange desired? */\n        private static _wantsHashChange: boolean;\n        /** @type {boolean} Is pushState desired and supportted in the current browser? */\n        private static _usePushState: boolean;\n\n        /**\n         * Start the routing system.\n         * @param {Object = {}} [options] The initialization options for the Router.\n         * @return {Router} The router.\n         */\n        static listen(options: Options = {}): Router {\n\n            if (Router._root !== undefined && Router._root !== null) {\n                throw new Error('Router already listening.');\n            }\n\n            for (let prop in DEF_OPTIONS) {\n                if (options[prop] === undefined) {\n                    options[prop] = DEF_OPTIONS[prop];\n                }\n            }\n\n            Router._wantsHashChange = options.hashChange;\n            Router._usePushState    = options.usePushState && !!(_global.history && _global.history.pushState);\n            Router._root = RouteHelper.ensureSlashes(options.root);\n\n            if (Router._usePushState) {\n                addEventListener('popstate', Router.heedCurrent, false);\n            } else if (Router._wantsHashChange) {\n                addEventListener('hashchange', Router.heedCurrent, false);\n            }\n\n            if (!options.silent) {\n                Router.heedCurrent();\n            }\n\n            return Router;\n        }\n\n        /**\n         * Disable the route-change-handling and resets the Router's state, perhaps temporarily.\n         * Not useful in a real app; but useful for unit testing.\n         * @return {Router} The router.\n         */\n        static stop(): Router {\n            removeEventListener('popstate', Router.heedCurrent, false);\n            removeEventListener('hashchange', Router.heedCurrent, false);\n            for (let propName in Router) {\n                if (Router.hasOwnProperty(propName) && typeof Router[propName] !== 'function') {\n                  Router[propName] = null;\n                }\n            }\n            Router._handlers = [];\n            return Router;\n        }\n\n        /**\n         * Retrieve the current path without the root prefix.\n         * @return {string} The current path.\n         */\n        static getCurrent(): string {\n\n            let path: string;\n\n            if (Router._usePushState || !Router._wantsHashChange) {\n                path = decodeURI(location.pathname + location.search);\n                // removes the root prefix from the path.\n                path = path.slice(Router._root.length);\n            } else {\n                const match = location.href.match(/#(.*)$/);\n                path = match ? match[1] : '';\n            }\n\n            path = RouteHelper.clearSlashes(path);\n\n            return path;\n        }\n\n        /**\n         * Add the given middleware as a handler for the given path (defaulting to any path).\n         * @param {string|Callback|RouteGroup} path The fragment or the callback.\n         * @param {Callback|RouteGroup} [activate] The activate callback or the group of routes.\n         * @return {Router} The router.\n         */\n        static use(path: any, activate?: any): Router {\n\n            if (activate instanceof RouteGroup || path instanceof RouteGroup) {\n                let parentPath: string;\n                if (path instanceof RouteGroup) {\n                    activate = path;\n                } else {\n                    parentPath = RouteHelper.clearSlashes(path);\n                }\n                Router._handlers = Router._extractHandlers(parentPath, activate, Router._handlers);\n            } else {\n                let pathExp: PathExp;\n                // If default route.\n                if (typeof path === 'function') {\n                    activate = path;\n                    pathExp = DEF_ROUTE;\n                } else {\n                    path = RouteHelper.clearSlashes(path);\n                    pathExp = RouteHelper.stringToPathExp(path);\n                }\n                Router._handlers.push({ pathExp, activate });\n            }\n\n            return Router;\n        }\n\n        /**\n         * Change the current path and load it.\n         * @param {string} path The fragment to navigate to.\n         * @returns {Router} The router.\n         */\n        static navigate(path: string): Router {\n\n            if (Router._root === undefined || Router._root === null) {\n                throw new Error(\"It is required to call the 'listen' function before navigating.\");\n            }\n\n            path = RouteHelper.clearSlashes(path);\n\n            if (Router._usePushState) {\n                history.pushState(null, null, Router._root + path);\n            } else if (Router._wantsHashChange) {\n                location.hash = '#' + path;\n            } else {\n                // If you've told us that you explicitly don't want fallback hashchange-\n                // based history, then `navigate` becomes a page refresh.\n                location.assign(Router._root + path);\n                return Router;\n            }\n\n            return Router.load(path);\n        }\n\n        /**\n         * Load the current path only if it has not been already heeded.\n         * @return {Router} The router.\n         */\n        static heedCurrent(): Router {\n            const currentPath = Router.getCurrent();\n            return currentPath === Router._loadedPath ? Router : Router.load(currentPath);\n        }\n\n        /**\n         * Attempt to loads the handlers matching the given URL fragment.\n         * @param {string} path The url fragment, e.g.: 'users/pinocho'\n         * @returns {Router} The router.\n         */\n        static load(path: string): Router {\n\n            const reqProcessors = Router._obtainRequestProcessors(path);\n\n            if (reqProcessors.length) {\n\n                let count = 0;\n\n                /** Anonymous function used for processing routing cycle. */\n                function next() {\n\n                    if (count >= reqProcessors.length) {\n                        return;\n                    }\n\n                    const reqProc = reqProcessors[count];\n\n                    count++;\n\n                    reqProc.request.oldPath = Router._loadedPath;\n\n                    const resp = reqProc.activate.call(null, reqProc.request, next);\n\n                    if (resp === true) {\n                        if (console && console.log) {\n                          console.log('\"return true\" is deprecated, use \"next()\" instead.');\n                        }\n                        next();\n                    }\n                }\n\n                next();\n            }\n\n            Router._loadedPath = path;\n\n            return Router;\n        }\n\n        /**\n         * Extract the handlers from the given arguments.\n         * @param  {string} parentPath The parent path of the group of routes.\n         * @param  {RouteGroup} routeGroup The group of routes.\n         * @param  {Handler[]=[]} [handlers] The holder for extracted handlers.\n         * @return {Handler[]} The extracted handlers.\n         */\n        private static _extractHandlers(parentPath: string, routeGroup: RouteGroup, handlers: Handler[] = []): Handler[] {\n\n            const groupHandlers = routeGroup._handlers;\n\n            for (let i = 0; i < groupHandlers.length; i++) {\n\n                const itHandler = groupHandlers[i];\n                let subPath: string;\n                let activate: Callback;\n\n                if (typeof itHandler.path === 'function') {\n                    activate = itHandler.path;\n                } else {\n                    activate = itHandler.activate;\n                    subPath = RouteHelper.clearSlashes(itHandler.path);\n                }\n\n                let pathExp: PathExp;\n\n                if (parentPath === undefined || subPath === undefined) {\n                    if (parentPath === undefined && subPath === undefined) {\n                        pathExp = DEF_ROUTE;\n                    } else if (parentPath === undefined) {\n                        pathExp = RouteHelper.stringToPathExp(subPath);\n                    } else {\n                        pathExp = RouteHelper.stringToPathExp(parentPath);\n                    }\n                } else {\n                    const path = parentPath + '/' + subPath;\n                    pathExp = RouteHelper.stringToPathExp(path);\n                }\n\n                handlers.push({ pathExp, activate });\n            }\n\n            return handlers;\n        }\n\n        /**\n         * Obtain the request processors for the given path according to the current handlers in the router.\n         * @param  {string} path The url fragment to check.\n         * @return {RequestProcessor[]} The obtained request processors.\n         */\n        private static _obtainRequestProcessors(path: string): RequestProcessor[] {\n\n            const parsedPath = RouteHelper.parsePath(path);\n\n            const requestProcessors: RequestProcessor[] = [];\n\n            for (let i = 0; i < Router._handlers.length; i++) {\n\n                const handler = Router._handlers[i];\n                const match = handler.pathExp.test(parsedPath.path);\n\n                if (match) {\n                    const request = Router._extractRequest(path, handler.pathExp);\n                    requestProcessors.push({ activate: handler.activate, request });\n                }\n            }\n\n            return requestProcessors;\n        }\n\n        /**\n         * Extract a request from the given arguments, using decoded parameters.\n         * @param {string} path The url fragment.\n         * @param {PathExp} [pathExp] The path expression.\n         * @returns {Request} The extracted request.\n         */\n        private static _extractRequest(path: string, pathExp?: PathExp): Request {\n\n            const request: Request = RouteHelper.parsePath(path);\n            request.params = {};\n\n            const result = pathExp.exec(request.path);\n            const args = result.slice(1);\n            const keys = pathExp.keys;\n\n            for (let i = 0; i < args.length; i++) {\n                if (args[i] !== undefined) {\n                    request.params[keys[i].name] = decodeURIComponent(args[i]);\n                }\n            }\n\n            return request;\n        }\n    }\n\n    /**\n     * Allows to use a group of routes as middleware.\n     */\n    export class RouteGroup {\n\n        /** @type {GroupHandler[]} The list of handlers for this group. */\n        _handlers: GroupHandler[] = [];\n\n        /**\n         * Add the given middleware function as handler for the given path (defaulting to any path).\n         * @param {string|Callback} path The fragment or the callback.\n         * @param {Callback} [activate] The activate callback.\n         * @return {RouteGroup} The router group.\n         */\n        use(path: any, activate?: Callback): RouteGroup {\n            this._handlers.push({ path, activate });\n            return this;\n        }\n    }\n\n}\n"]}