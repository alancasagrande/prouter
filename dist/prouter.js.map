{"version":3,"file":"prouter.js","sourceRoot":"/source/","sources":["prouter.ts"],"names":["prouter","prouter.RouteHelper","prouter.RouteHelper.constructor","prouter.RouteHelper._escapeString","prouter.RouteHelper._escapeGroup","prouter.RouteHelper.clearSlashes","prouter.RouteHelper._flags","prouter.RouteHelper._parse","prouter.RouteHelper._tokensToPathExp","prouter.RouteHelper.parseSearchString","prouter.RouteHelper.parsePath","prouter.RouteHelper.stringToPathExp","prouter.Router","prouter.Router.constructor","prouter.Router.listen","prouter.Router.config","prouter.Router.stop","prouter.Router.getCurrent","prouter.Router.navigate","prouter.Router.use","prouter.Router._loadCurrent","prouter.Router._load","prouter.Router._obtainHandlers","prouter.Router._obtainRequest","prouter.Router._obtainRequestProcessors","prouter.RouteGroup","prouter.RouteGroup.constructor","prouter.RouteGroup.use"],"mappings":"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","sourcesContent":["module prouter {\r\n\r\n    export interface Options {\r\n        mode?: string;\r\n        root?: string;\r\n    }\r\n\r\n    export interface PathExp extends RegExp {\r\n        keys?: PathExpToken[];\r\n    }\r\n    \r\n    export interface Path {\r\n        path: string;\r\n        query: Object;\r\n        queryString: string;\r\n    }    \r\n\r\n    export interface PathExpToken {\r\n        name: string;\r\n        prefix: string;\r\n        delimiter: string;\r\n        optional: boolean;\r\n        repeat: boolean;\r\n        pattern: string;\r\n    }\r\n\r\n    export interface Handler {\r\n        pathExp: PathExp;\r\n        activate: Function;\r\n    }\r\n\r\n    export interface GroupHandler {\r\n        path: any;\r\n        activate: Function;\r\n    }\r\n    \r\n    export interface Param {\r\n        [index: string]: string;\r\n    }\r\n    \r\n    export interface Request extends Path {\r\n        params?: Param;\r\n        old?: string;\r\n    }\r\n\r\n    export interface RequestEvent {\r\n        activate: Function;\r\n        request: Request;\r\n    }    \r\n\r\n    declare const global: any;\r\n\r\n    // Establish the root object, `window` (`self`) in the browser, or `global` on the server.\r\n    // We use `self` instead of `window` for `WebWorker` support.\r\n    const _global = (typeof self === 'object' && self.self === self && self) ||\r\n        (typeof global === 'object' && global.global === global && global);\r\n\r\n    const _DEF_OPTIONS: Options = { mode: 'hash', root: '/' };\r\n\r\n    /**\r\n     * The main path matching regexp utility.\r\n     * @type {RegExp} path regexp.\r\n     */\r\n    const PATH_STRIPPER = new RegExp([\r\n    // Match escaped characters that would otherwise appear in future matches.\r\n    // This allows the user to escape special characters that won't transform.\r\n        '(\\\\\\\\.)',\r\n    // Match Express-style parameters and un-named parameters with a prefix\r\n    // and optional suffixes. Matches appear as:\r\n    //\r\n    // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\r\n    // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\r\n    // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\r\n        '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\r\n    ].join('|'), 'g');\r\n    \r\n    // Cached regex for default route.\r\n    const DEF_ROUTE = /.*/;\r\n\r\n\r\n    class RouteHelper {             \r\n\r\n        /**\r\n         * Escape a regular expression string.\r\n         * @param  {String} str the string to scape\r\n         * @return {String} the escaped string\r\n         */\r\n        private static _escapeString(str: string): string {\r\n            return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1');\r\n        }\r\n\r\n        /**\r\n         * Escape the capturing group by escaping special characters and meaning.\r\n         * @param  {String} group the group to escape\r\n         * @return {String} escaped group.\r\n         */\r\n        private static _escapeGroup(group: string): string {\r\n            return group.replace(/([=!:$\\/()])/g, '\\\\$1');\r\n        }\r\n\r\n        static clearSlashes(path: string): string {\r\n            return path.replace(/\\/$/, '').replace(/^\\//, '');\r\n        }\r\n\r\n        /**\r\n         * Get the flags for a regexp from the options.\r\n         * @param  {Object} opts the options object for building the flags.\r\n         * @return {String} flags.\r\n         */\r\n        private static _flags(opts: Object): string {\r\n            return opts['sensitive'] ? '' : 'i';\r\n        }        \r\n        \r\n        /**\r\n         * Parse a string for the raw tokens.\r\n         * @param  {String} path\r\n         * @return {Array} tokens.\r\n         */\r\n        private static _parse(path: string): any[] {\r\n\r\n            const tokens: any[] = [];\r\n            let key = 0;\r\n            let index = 0;\r\n            let pathIt = '';\r\n            let res: RegExpExecArray;\r\n\r\n            while ((res = PATH_STRIPPER.exec(path))) {\r\n\r\n                const m = res[0];\r\n                const escaped = res[1];\r\n                const offset = res.index;\r\n\r\n                pathIt += path.slice(index, offset);\r\n                index = offset + m.length;\r\n\r\n                // Ignore already escaped sequences.\r\n                if (escaped) {\r\n                    pathIt += escaped[1];\r\n                    continue;\r\n                }\r\n\r\n                // Push the current path onto the tokens.\r\n                if (pathIt) {\r\n                    tokens.push(pathIt);\r\n                    pathIt = '';\r\n                }\r\n\r\n                const prefix = res[2];\r\n                const name = res[3];\r\n                const capture = res[4];\r\n                const group = res[5];\r\n                const suffix = res[6];\r\n                const asterisk = res[7];\r\n\r\n                const repeat = suffix === '+' || suffix === '*';\r\n                const optional = suffix === '?' || suffix === '*';\r\n                const delimiter = prefix || '/';\r\n                const pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\r\n\r\n                tokens.push({\r\n                    name: name || (key++).toString(),\r\n                    prefix: prefix || '',\r\n                    delimiter: delimiter,\r\n                    optional: optional,\r\n                    repeat: repeat,\r\n                    pattern: RouteHelper._escapeGroup(pattern)\r\n                });\r\n            }\r\n\r\n            // Match any characters still remaining.\r\n            if (index < path.length) {\r\n                pathIt += path.substr(index);\r\n            }\r\n\r\n            // If the path exists, push it onto the end.\r\n            if (pathIt) {\r\n                tokens.push(pathIt);\r\n            }\r\n\r\n            return tokens;\r\n        }\r\n\r\n        /**\r\n         * Expose a function for taking tokens and returning a RegExp.\r\n         * @param  {Array}  tokens\r\n         * @param  {Object} options\r\n         * @return {RegExp} the regexp.\r\n         */\r\n        private static _tokensToPathExp(tokens: any[], options: Object = {}): PathExp {\r\n\r\n            const strict = options['strict'];\r\n            const end = options['end'] !== false;\r\n            let route = '';\r\n            const lastToken = tokens[tokens.length - 1];\r\n            const endsWithSlash = typeof lastToken === 'string' && lastToken.length && lastToken.charAt(lastToken.length - 1) === '/';\r\n\r\n            // Iterate over the tokens and create our regexp string.\r\n            for (let i = 0; i < tokens.length; i++) {\r\n\r\n                const token = tokens[i];\r\n\r\n                if (typeof token === 'string') {\r\n                    route += RouteHelper._escapeString(token);\r\n                } else {\r\n\r\n                    const prefix = RouteHelper._escapeString(token.prefix);\r\n                    let capture = token.pattern;\r\n\r\n                    if (token.repeat) {\r\n                        capture += '(?:' + prefix + capture + ')*';\r\n                    }\r\n\r\n                    if (token.optional) {\r\n                        if (prefix) {\r\n                            capture = '(?:' + prefix + '(' + capture + '))?';\r\n                        } else {\r\n                            capture = '(' + capture + ')?';\r\n                        }\r\n                    } else {\r\n                        capture = prefix + '(' + capture + ')';\r\n                    }\r\n\r\n                    route += capture;\r\n                }\r\n            }\r\n\r\n            // In non-strict mode we allow a slash at the end of match. If the path to\r\n            // match already ends with a slash, we remove it for consistency. The slash\r\n            // is valid at the end of a path match, not in the middle. This is important\r\n            // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\r\n            if (!strict) {\r\n                route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\r\n            }\r\n\r\n            if (end) {\r\n                route += '$';\r\n            } else {\r\n                // In non-ending mode, we need the capturing groups to match as much as\r\n                // possible by using a positive lookahead to the end or next path segment.\r\n                route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\r\n            }\r\n\r\n            return new RegExp('^' + route, RouteHelper._flags(options));\r\n        }\r\n\r\n        static parseSearchString(search: string): Object {\r\n            const searchParams = {};\r\n            if (search.charAt(0) === '?') {\r\n                search = search.slice(1);\r\n            }\r\n            const paramsArr = search.split('&');\r\n            for (let i = 0; i < paramsArr.length; i++) {\r\n                const pair = paramsArr[i].split('=');\r\n                searchParams[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n            }\r\n            return searchParams;\r\n        }\r\n\r\n        static parsePath(path: string): Path {\r\n\r\n            let parser: any;\r\n\r\n            if (typeof _global.URL === 'function') {\r\n                parser = new _global.URL(path, 'http://example.com');\r\n            } else {\r\n                parser = document.createElement('a');\r\n                parser.href = 'http://example.com/' + path;\r\n            }\r\n\r\n            const parsedPath: Path = {\r\n                path: RouteHelper.clearSlashes(parser.pathname),\r\n                query: RouteHelper.parseSearchString(parser.search),\r\n                queryString: parser.search\r\n            };\r\n\r\n            return parsedPath;\r\n        }                           \r\n\r\n        /**\r\n         * Create a path regexp from string input.\r\n         * @param  {String} path\r\n         * @param  {Object} options\r\n         * @return {RegExp} the regexp\r\n         */\r\n        static stringToPathExp(path: string, options?: Object): PathExp {\r\n\r\n            const tokens = RouteHelper._parse(path);\r\n\r\n            const pathExp = RouteHelper._tokensToPathExp(tokens, options);\r\n\r\n            pathExp.keys = [];                   \r\n\r\n            // Attach keys back to the regexp.\r\n            for (let i = 0; i < tokens.length; i++) {\r\n                if (typeof tokens[i] !== 'string') {\r\n                    pathExp.keys.push(tokens[i]);\r\n                }\r\n            }\r\n\r\n            return pathExp;\r\n        }\r\n    }\r\n\r\n\r\n    export class Router {\r\n\r\n        private static _handlers: Handler[] = [];\r\n        private static _options: Options = {};\r\n        private static _listening = false;\r\n\r\n        static listen(options: Options): Router {\r\n            if (this._listening) {\r\n                throw new Error('Router already listening.');\r\n            }\r\n            this._listening = true;\r\n            this.config(options);\r\n            switch (this._options.mode) {\r\n                case 'history':\r\n                    addEventListener('popstate', this._loadCurrent, false);\r\n                    break;\r\n                case 'hash':\r\n                    addEventListener('hashchange', this._loadCurrent, false);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"Invalid mode '\" + this._options.mode + \"'. Valid modes are: 'history', 'hash'.\");\r\n            }\r\n            return this;\r\n        }\r\n\r\n        static config(options: Options): Router {\r\n            for (let prop in _DEF_OPTIONS) {\r\n                if (options[prop] !== undefined) {\r\n                    this._options[prop] = options[prop];\r\n                } else if (this._options[prop] === undefined) {\r\n                    this._options[prop] = _DEF_OPTIONS[prop];\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        static stop(): Router {\r\n            if (this._options.mode === 'history') {\r\n                removeEventListener('popstate', this._loadCurrent, false);\r\n                history.pushState(null, null, this._options.root);\r\n            } else {\r\n                removeEventListener('hashchange', this._loadCurrent, false);\r\n                location.hash = '#';\r\n            }\r\n            this._handlers = [];\r\n            this._listening = false;\r\n            return this;\r\n        }        \r\n\r\n        static getCurrent(): string {\r\n            \r\n            let fragment: string;\r\n\r\n            if (this._options.mode === 'history') {\r\n                const root = this._options.root;\r\n                fragment = RouteHelper.clearSlashes(decodeURI(location.pathname + location.search));\r\n                fragment = fragment.replace(/\\?(.*)$/, '');\r\n                fragment = root !== '/' ? fragment.replace(root, '') : fragment;\r\n            } else {\r\n                const match = location.href.match(/#(.*)$/);\r\n                fragment = match ? match[1] : '';\r\n            }\r\n\r\n            fragment = RouteHelper.clearSlashes(fragment);\r\n\r\n            return fragment;\r\n        }\r\n\r\n        static navigate(path: string) {\r\n\r\n            path = RouteHelper.clearSlashes(path);\r\n\r\n            switch (this._options.mode) {\r\n                case 'history':\r\n                    this._load(path);\r\n                    history.pushState(null, null, this._options.root + path);\r\n                    break;\r\n                case 'hash':\r\n                    const oldPath = this.getCurrent();\r\n                    // If the path has not changed, force _loadPath since the 'hashchange' event will not be triggered.\r\n                    if (path === oldPath) {\r\n                        this._load(path);\r\n                    }\r\n                    location.hash = '#' + path;\r\n                    break;\r\n            }\r\n        }\r\n        \r\n        static use(path: any, activate?: any): Router {\r\n            \r\n            if (activate instanceof RouteGroup || path instanceof RouteGroup) {\r\n                let parentPath: string;\r\n                if (path instanceof RouteGroup) {\r\n                    activate = path;\r\n                } else {\r\n                    parentPath = RouteHelper.clearSlashes(path);\r\n                }\r\n                this._handlers = this._obtainHandlers(parentPath, activate);\r\n            } else {\r\n                let pathExp: PathExp;\r\n                // If default route.\r\n                if (typeof path === 'function') {\r\n                    activate = path;\r\n                    pathExp = DEF_ROUTE;\r\n                } else {\r\n                    path = RouteHelper.clearSlashes(path);\r\n                    pathExp = RouteHelper.stringToPathExp(path);\r\n                }\r\n                this._handlers.push({pathExp, activate});\r\n            }\r\n            \r\n            return this;\r\n        }\r\n\r\n        private static _loadCurrent(): boolean {\r\n            const path = this.getCurrent();\r\n            return this._load(path);\r\n        }\r\n\r\n        private static _load(path: string): boolean {\r\n\r\n            const requestProcessors = this._obtainRequestProcessors(path);\r\n            const current = this.getCurrent();\r\n\r\n            let count = 0;\r\n\r\n            for (let i = 0; i < requestProcessors.length; i++) {\r\n                const requestProcessor = requestProcessors[i];\r\n                requestProcessor.request.old = current;\r\n                const next = requestProcessor.activate.call(null, requestProcessor.request);\r\n                if (next === false) {\r\n                    break;\r\n                } else {\r\n                    count++;\r\n                }\r\n            }\r\n\r\n            return count > 0;\r\n        }                \r\n\r\n        private static _obtainHandlers(parentPath: string, routeGroup: RouteGroup, handlers: Handler[] = []): Handler[] {\r\n\r\n            const groupHandlers = routeGroup._handlers;\r\n\r\n            for (let i = 0; i < groupHandlers.length; i++) {\r\n\r\n                const itHandler = groupHandlers[i];\r\n                let subPath: string;\r\n                let activate: Function;\r\n\r\n                if (typeof itHandler.path === 'function') {\r\n                    activate = itHandler.path;\r\n                } else {\r\n                    activate = itHandler.activate;\r\n                    subPath = RouteHelper.clearSlashes(itHandler.path);\r\n                }\r\n\r\n                let pathExp: PathExp;\r\n\r\n                if (parentPath === undefined || subPath === undefined) {\r\n                    if (parentPath === undefined && subPath === undefined) {\r\n                        pathExp = DEF_ROUTE;\r\n                    } else if (parentPath === undefined) {\r\n                        pathExp = RouteHelper.stringToPathExp(subPath);\r\n                    } else {\r\n                        pathExp = RouteHelper.stringToPathExp(parentPath);\r\n                    }\r\n                } else {\r\n                    const path = parentPath + '/' + subPath;\r\n                    pathExp = RouteHelper.stringToPathExp(path);\r\n                }\r\n\r\n                handlers.push({ pathExp, activate });\r\n            }\r\n\r\n            return handlers;\r\n        }\r\n        \r\n        /**\r\n         * Given a route, and a path that it matches, return the object of\r\n         * extracted decoded parameters.\r\n         * @param {string} path The uri's path part.\r\n         * @param {PathExp} route The alias         \r\n         * @returns {NavigationParams} the extracted parameters\r\n         * @private\r\n         */\r\n        private static _obtainRequest(path: string, pathExp: PathExp): Request {\r\n\r\n            const request: Request = RouteHelper.parsePath(path);\r\n            request.params = {};\r\n\r\n            const result = pathExp ? pathExp.exec(request.path) : null;\r\n\r\n            if (!result) {\r\n                return request;\r\n            }\r\n\r\n            const args = result.slice(1);\r\n            const keys = pathExp.keys;\r\n\r\n            for (let i = 0; i < args.length; i++) {\r\n                if (args[i] !== undefined) {\r\n                    request.params[keys[i].name] = decodeURIComponent(args[i]);\r\n                }\r\n            }\r\n\r\n            return request;\r\n        }\r\n\r\n        private static _obtainRequestProcessors(path: string): RequestEvent[] {\r\n\r\n            const parsedPath = RouteHelper.parsePath(path);\r\n\r\n            const requestProcessors: RequestEvent[] = [];\r\n\r\n            for (let i = 0; i < this._handlers.length; i++) {\r\n\r\n                const handler = this._handlers[i];\r\n                const match = handler.pathExp.test(parsedPath.path);\r\n\r\n                if (match) {\r\n\r\n                    const request = this._obtainRequest(path, handler.pathExp);\r\n\r\n                    const requestProcessor: RequestEvent = {activate: handler.activate, request};\r\n\r\n                    requestProcessors.push(requestProcessor);\r\n                }\r\n            }\r\n\r\n            return requestProcessors;\r\n        }\r\n    }\r\n\r\n\r\n    export class RouteGroup {\r\n        _handlers: GroupHandler[] = [];\r\n        use(path: any, activate?: Function) {\r\n            this._handlers.push({ path, activate });\r\n        }\r\n    }\r\n\r\n}"]}