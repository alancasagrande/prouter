{"version":3,"sources":["prouter.ts","prouter.js"],"names":["Resource","Resource.constructor","Resource.full","RouteHelper","RouteHelper.constructor","RouteHelper._escapeString","RouteHelper._escapeGroup","RouteHelper._flags","RouteHelper.parseQuery","RouteHelper.parseFragment","RouteHelper.decodeFragment","RouteHelper._parse","RouteHelper._tokensToRegExp","RouteHelper.stringToRegexp","History","History.constructor","History.on","History.off","History.trigger","History.isAtRoot","History.getCurrentPath","History.getCurrentHash","History.obtainFragment","History.start","History.stop","History._add","History.navigate","History._checkUrl","History._loadUrl","History._updateHash","Router","Router.constructor","Router._bindHandlers","Router.add","Router._extractParameters"],"mappings":"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","file":"prouter.js","sourcesContent":["/**\r\n * Unobtrusive, forward-thinking and lightweight JavaScript router library.\r\n */\r\n\r\ndeclare const global: any;\r\n\r\n// Establish the root object, `window` (`self`) in the browser, or `global` on the server.\r\n// We use `self` instead of `window` for `WebWorker` support.\r\nconst _global = (typeof self === 'object' && self.self === self && self) ||\r\n    (typeof global === 'object' && global.global === global && global);\r\n\r\n/**\r\n * Contract for event handler.\r\n */\r\nexport interface NavigationParams {\r\n    [index: string]: string;\r\n}\r\n\r\n/**\r\n * Contract for navigation data.\r\n */\r\nexport interface NavigationData {\r\n    path: string;\r\n    params: NavigationParams;\r\n    query: string;\r\n    message?: any;\r\n    handler?: Handler;\r\n}\r\n\r\n/**\r\n * Contract for route-entry's callback.\r\n */\r\nexport interface HandlerCallback {\r\n    (newRouteData: NavigationData, oldRouteData?: NavigationData): void;\r\n}\r\n\r\n/**\r\n * Contract of route handler.\r\n */\r\nexport interface Handler {\r\n    route: string;\r\n    activate: HandlerCallback;\r\n    deactivate?: HandlerCallback;\r\n}\r\n\r\n/**\r\n * Contract for navigation options.\r\n */\r\nexport interface NavigationOptions {\r\n    trigger?: boolean;\r\n    replace?: boolean;\r\n}\r\n\r\n/**\r\n * Contract for History.start options parameters.\r\n */\r\nexport interface HistoryOptions {\r\n    root?: string;\r\n    hashChange?: boolean;\r\n    pushState?: boolean;\r\n    silent?: boolean;\r\n}\r\n\r\n/**\r\n * Contract for route-entry's callback.\r\n */\r\ninterface RouteCallback {\r\n    (resource: Resource, newRouteData: NavigationData, oldRouteData?: NavigationData): void;\r\n}\r\n\r\n/**\r\n * Contract for entry handler.\r\n */\r\ninterface Route {\r\n    route: RegExp;\r\n    callback: RouteCallback;\r\n}\r\n\r\n/**\r\n * Contract for entry handler.\r\n */\r\nexport class Resource {\r\n    private _full: string;\r\n    constructor(public path: string, public query?: string) {\r\n        this._full = this.path;\r\n        if (this.query !== undefined && this.query !== null && this.query !== '') {\r\n            this._full += '?' + this.query;\r\n        }\r\n    }\r\n    get full(): string {\r\n        return this._full;\r\n    }\r\n}\r\n\r\n/**\r\n * Contract for event handler.\r\n */\r\ninterface EventHandler {\r\n    [index: string]: Function[];\r\n}\r\n\r\n\r\n/**\r\n * The main path matching regexp utility.\r\n * @type {RegExp} path regexp.\r\n */\r\nconst PATH_STRIPPER = new RegExp([\r\n// Match escaped characters that would otherwise appear in future matches.\r\n// This allows the user to escape special characters that won't transform.\r\n    '(\\\\\\\\.)',\r\n// Match Express-style parameters and un-named parameters with a prefix\r\n// and optional suffixes. Matches appear as:\r\n//\r\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\r\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\r\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\r\n    '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\r\n].join('|'), 'g');\r\n\r\n// Cached regex for stripping a leading hash/slash and trailing space.\r\nconst ROUTE_STRIPPER = /^[#\\/]|\\s+$/g;\r\n\r\n// Cached regex for stripping urls of hash.\r\nconst HASH_STRIPPER = /#.*$/;\r\n\r\nconst isArray = Array.isArray || function(obj: any): boolean {\r\n    return Object.prototype.toString.call(obj) === '[object Array]';\r\n};\r\n\r\n\r\nclass RouteHelper {\r\n\r\n    /**\r\n     * Escape a regular expression string.\r\n     * @param  {String} str the string to scape\r\n     * @return {String} the escaped string\r\n     */\r\n    private static _escapeString(str: string): string {\r\n        return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1');\r\n    }\r\n\r\n    /**\r\n     * Escape the capturing group by escaping special characters and meaning.\r\n     * @param  {String} group the group to escape\r\n     * @return {String} escaped group.\r\n     */\r\n    private static _escapeGroup(group: string): string {\r\n        return group.replace(/([=!:$\\/()])/g, '\\\\$1');\r\n    }\r\n\r\n    /**\r\n     * Get the flags for a regexp from the options.\r\n     * @param  {Object} opts the options object for building the flags.\r\n     * @return {String} flags.\r\n     */\r\n    private static _flags(opts: Object): string {\r\n        return opts['sensitive'] ? '' : 'i';\r\n    }\r\n\r\n    static parseQuery(queryString: string): Object {\r\n        const query = {};\r\n        const params = queryString.split('&');\r\n        for (let i = 0; i < params.length; i++) {\r\n            let pair = params[i].split('=');\r\n            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n        }\r\n        return query;\r\n    }\r\n\r\n    /**\r\n     * Parse the given uri.\r\n     * @param  {string} uri the url to parse\r\n     * @return {Resource} parsed uri\r\n     */\r\n    static parseFragment(fragment: string): Resource {\r\n\r\n        if (fragment === '') {\r\n            return new Resource(fragment);\r\n        }\r\n\r\n        const qsPos = fragment.indexOf('?');\r\n\r\n        let path: string;\r\n        let query: string;\r\n\r\n        fragment = RouteHelper.decodeFragment(fragment).replace(ROUTE_STRIPPER, '');\r\n\r\n        if (qsPos >= 0) {\r\n            path = fragment.slice(0, qsPos);\r\n            query = fragment.slice(qsPos + 1);\r\n        } else {\r\n            path = fragment;\r\n        }\r\n\r\n        return new Resource(path, query);\r\n    }\r\n\r\n    /**\r\n     *  Unicode characters in `location.pathname` are percent encoded so they're\r\n     *  decoded for comparison. `%25` should not be decoded since it may be part\r\n     *  of an encoded parameter.\r\n     *  @param {string} fragment The url fragment to decode\r\n     *  @returns {string} the decoded fragment.\r\n     */\r\n    static decodeFragment(fragment: string): string {\r\n        fragment = fragment.replace(/%25/g, '%2525');\r\n        return _global.decodeURI(fragment);\r\n    }\r\n\r\n    /**\r\n     * Parse a string for the raw tokens.\r\n     * @param  {String} str\r\n     * @return {Array} tokens.\r\n     */\r\n    private static _parse(str: string): Object[] {\r\n\r\n        const tokens: Object[] = [];\r\n        let key = 0;\r\n        let index = 0;\r\n        let path = '';\r\n        let res: RegExpExecArray;\r\n\r\n        while ((res = PATH_STRIPPER.exec(str))) {\r\n\r\n            const m = res[0];\r\n            const escaped = res[1];\r\n            const offset = res.index;\r\n\r\n            path += str.slice(index, offset);\r\n            index = offset + m.length;\r\n\r\n            // Ignore already escaped sequences.\r\n            if (escaped) {\r\n                path += escaped[1];\r\n                continue;\r\n            }\r\n\r\n            // Push the current path onto the tokens.\r\n            if (path) {\r\n                tokens.push(path);\r\n                path = '';\r\n            }\r\n\r\n            const prefix = res[2];\r\n            const name = res[3];\r\n            const capture = res[4];\r\n            const group = res[5];\r\n            const suffix = res[6];\r\n            const asterisk = res[7];\r\n\r\n            const repeat = suffix === '+' || suffix === '*';\r\n            const optional = suffix === '?' || suffix === '*';\r\n            const delimiter = prefix || '/';\r\n            const pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\r\n\r\n            tokens.push({\r\n                name: name || key++,\r\n                prefix: prefix || '',\r\n                delimiter: delimiter,\r\n                optional: optional,\r\n                repeat: repeat,\r\n                pattern: RouteHelper._escapeGroup(pattern)\r\n            });\r\n        }\r\n\r\n        // Match any characters still remaining.\r\n        if (index < str.length) {\r\n            path += str.substr(index);\r\n        }\r\n\r\n        // If the path exists, push it onto the end.\r\n        if (path) {\r\n            tokens.push(path);\r\n        }\r\n\r\n        return tokens;\r\n    }\r\n\r\n    /**\r\n     * Expose a function for taking tokens and returning a RegExp.\r\n     * @param  {Array}  tokens\r\n     * @param  {Object} options\r\n     * @return {RegExp} the regexp.\r\n     */\r\n    private static _tokensToRegExp(tokens: Object[], options: Object = {}): RegExp {\r\n\r\n        const strict = options['strict'];\r\n        const end = options['end'] !== false;\r\n        let route = '';\r\n        const lastToken = tokens[tokens.length - 1];\r\n        const endsWithSlash = typeof lastToken === 'string' && lastToken.length && lastToken.charAt(lastToken.length - 1) === '/';\r\n\r\n        // Iterate over the tokens and create our regexp string.\r\n        for (let i = 0; i < tokens.length; i++) {\r\n\r\n            const token: any = tokens[i];\r\n\r\n            if (typeof token === 'string') {\r\n                route += RouteHelper._escapeString(token);\r\n            } else {\r\n\r\n                const prefix = RouteHelper._escapeString(token.prefix);\r\n                let capture = token.pattern;\r\n\r\n                if (token.repeat) {\r\n                    capture += '(?:' + prefix + capture + ')*';\r\n                }\r\n\r\n                if (token.optional) {\r\n                    if (prefix) {\r\n                        capture = '(?:' + prefix + '(' + capture + '))?';\r\n                    } else {\r\n                        capture = '(' + capture + ')?';\r\n                    }\r\n                } else {\r\n                    capture = prefix + '(' + capture + ')';\r\n                }\r\n\r\n                route += capture;\r\n            }\r\n        }\r\n\r\n        // In non-strict mode we allow a slash at the end of match. If the path to\r\n        // match already ends with a slash, we remove it for consistency. The slash\r\n        // is valid at the end of a path match, not in the middle. This is important\r\n        // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\r\n        if (!strict) {\r\n            route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\r\n        }\r\n\r\n        if (end) {\r\n            route += '$';\r\n        } else {\r\n            // In non-ending mode, we need the capturing groups to match as much as\r\n            // possible by using a positive lookahead to the end or next path segment.\r\n            route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\r\n        }\r\n\r\n        return new RegExp('^' + route, RouteHelper._flags(options));\r\n    }\r\n\r\n    /**\r\n     * Create a path regexp from string input.\r\n     * @param  {String} path\r\n     * @param  {Array}  keys\r\n     * @param  {Object} options\r\n     * @return {RegExp} the regexp\r\n     */\r\n    static stringToRegexp(path: string, keys: Object[] = [], options?: Object): RegExp {\r\n\r\n        const tokens = RouteHelper._parse(path);\r\n        const re = RouteHelper._tokensToRegExp(tokens, options);\r\n\r\n        // Attach keys back to the regexp.\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            if (typeof tokens[i] !== 'string') {\r\n                keys.push(tokens[i]);\r\n            }\r\n        }\r\n\r\n        re['keys'] = keys;\r\n\r\n        return re;\r\n    }\r\n}\r\n\r\n/**\r\n * Handles cross-browser history management, based on either\r\n * [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n * [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n * and URL fragments.\r\n * @constructor\r\n */\r\nexport class History {\r\n\r\n    // Has the history handling already been started?\r\n    private static _started = false;\r\n    private _location = _global.location;\r\n    private _history = _global.history;\r\n    private _handlers: Route[] = [];\r\n    private _eventHandlers: EventHandler = {};\r\n    private _root: string;\r\n    private _hasPushState: boolean;\r\n    private _wantsHashChange: boolean;\r\n    private _wantsPushState: boolean;\r\n    private _usePushState: boolean;\r\n    private _fragment: Resource;\r\n\r\n    constructor() {\r\n        this._checkUrl = this._checkUrl.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Add event listener.\r\n     * @param {string} evt Name of the event.\r\n     * @param {Function} callback Method.\r\n     * @returns {History} this history\r\n     */\r\n    on(evt: string, callback: Function): History {\r\n        if (this._eventHandlers[evt] === undefined) {\r\n            this._eventHandlers[evt] = [];\r\n        }\r\n        this._eventHandlers[evt].push(callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove event listener.\r\n     * @param {string} evt Name of the event.\r\n     * @param {Function} callback Method.\r\n     * @returns {History} this history\r\n     */\r\n    off(evt: string, callback: Function): History {\r\n        if (this._eventHandlers[evt]) {\r\n            const callbacks = this._eventHandlers[evt];\r\n            for (let i = 0; i < callbacks.length; i++) {\r\n                if (callbacks[i] === callback) {\r\n                    callbacks.splice(i, 1);\r\n                    if (callbacks.length === 0) {\r\n                        delete this._eventHandlers[evt];\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Events triggering.\r\n     * @param {string} evt Name of the event being triggered.\r\n     * @return {boolean} null if not suscriptors, false if the event was cancelled for some suscriptor, true otherwise.\r\n     */\r\n    trigger(evt: string, ...restParams: any[]): boolean {\r\n        const callbacks = this._eventHandlers[evt];\r\n        if (callbacks === undefined || !callbacks.length) {\r\n            return null;\r\n        }\r\n        for (let i = 0; i < callbacks.length; i++) {\r\n            const respIt = callbacks[i].apply(this, restParams);\r\n            // check if some listener cancelled the event.\r\n            if (respIt === false) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Are we at the app root?\r\n     * @returns {boolean} if we are in the root.\r\n     */\r\n    isAtRoot(): boolean {\r\n        const path = this._location.pathname.replace(/[^\\/]$/, '$&/');\r\n        return path === this._root && !this._location.search;\r\n    }\r\n\r\n    /**\r\n     *  Get the pathname and search params, without the root.\r\n     *  @returns {Resource} The path.\r\n     */\r\n    getCurrentPath(): Resource {\r\n\r\n        let path = RouteHelper.decodeFragment(this._location.pathname).slice(this._root.length - 1);\r\n\r\n        if (path.charAt(0) === '/') {\r\n            path = path.slice(1);\r\n        }\r\n\r\n        const query = _global.decodeURIComponent(this._location.search.slice(1));\r\n\r\n        let full = path;\r\n\r\n        if (query) {\r\n            full += '?' + query;\r\n        }\r\n\r\n        return new Resource(path, query);\r\n    }\r\n\r\n    /**\r\n     * Gets the true hash value. Cannot use location.hash directly due to bug\r\n     * in Firefox where location.hash will always be decoded.\r\n     * @returns {Resource} The hash.\r\n     */\r\n    getCurrentHash(): Resource {\r\n        const match = this._location.href.match(/#(.*)$/);\r\n        const path = match ? match[1] : '';\r\n        return RouteHelper.parseFragment(path);\r\n    }\r\n\r\n    /**\r\n     * Get the cross-browser normalized URL fragment, either from the URL,\r\n     * the hash, or the override.\r\n     * @param {string} fragment The url fragment\r\n     * @returns {Resource} The fragment.\r\n     */\r\n    obtainFragment(fragment?: string): Resource {\r\n\r\n        if (fragment === undefined || fragment === null) {\r\n            if (this._usePushState || !this._wantsHashChange) {\r\n                return this.getCurrentPath();\r\n            }\r\n            return this.getCurrentHash();\r\n        }\r\n\r\n        return RouteHelper.parseFragment(fragment);\r\n    }\r\n\r\n    /**\r\n     * Start the route change handling, returning `true` if the current URL matches\r\n     * an existing route, and `false` otherwise.\r\n     * @param {Object} options Options\r\n     * @returns {boolean} true if the current fragment matched some handler, false otherwise.\r\n     */\r\n    start(options: HistoryOptions = {}): boolean {\r\n\r\n        if (History._started) {\r\n            throw new Error('Router.history has already been started');\r\n        }\r\n\r\n        History._started = true;\r\n\r\n        // Figure out the initial configuration. Is pushState desired ...\r\n        this._root = options.root || '/';\r\n        this._wantsHashChange = options.hashChange !== false;\r\n        this._wantsPushState = !!options.pushState;\r\n        this._hasPushState = !!(this._history && this._history.pushState);\r\n        this._usePushState = this._wantsPushState && this._hasPushState;\r\n\r\n        this._fragment = this.obtainFragment();\r\n\r\n        // Normalize root to always include a leading and trailing slash.\r\n        this._root = ('/' + this._root + '/').replace(/^\\/{2,}|\\/{2,}$/g, '/');\r\n\r\n        // Transition from hashChange to pushState or vice versa if both are\r\n        // requested.\r\n        if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n            const isAtRoot = this.isAtRoot();\r\n\r\n            // If we've started off with a route from a `pushState`-enabled\r\n            // browser, but we're currently in a browser that doesn't support it...\r\n            if (!this._hasPushState && !isAtRoot) {\r\n\r\n                const rootAux = this._root.slice(0, -1) || '/';\r\n                this._location.replace(rootAux + '#' + this.getCurrentPath().full);\r\n                // Return immediately as browser will do redirect to new url\r\n                return true;\r\n\r\n                // Or if we've started out with a hash-based route, but we're currently\r\n                // in a browser where it could be `pushState`-based instead...\r\n            } else if (this._hasPushState && isAtRoot) {\r\n                this.navigate(this.getCurrentHash().full, null, { replace: true, trigger: false });\r\n            }\r\n        }\r\n\r\n        // Depending on whether we're using pushState or hashes, and whether\r\n        // 'onhashchange' is supported, determine how we check the URL state.\r\n        if (this._usePushState) {\r\n            _global.addEventListener('popstate', this._checkUrl, false);\r\n        } else if (this._wantsHashChange) {\r\n            _global.addEventListener('hashchange', this._checkUrl, false);\r\n        }\r\n\r\n        if (!options.silent) {\r\n            return this._loadUrl();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disable Router.history, perhaps temporarily. Not useful in a real app,\r\n     * but possibly useful for unit testing Routers.\r\n     */\r\n    stop() {\r\n        _global.removeEventListener('popstate', this._checkUrl, false);\r\n        _global.removeEventListener('hashchange', this._checkUrl, false);\r\n        History._started = false;\r\n    }\r\n\r\n    /**\r\n     * Add a route to be tested when the fragment changes. Routes added first\r\n     * takes priority.\r\n     * @param {RegExp} rRoute The route.\r\n     * @param {RouteCallback} callback Method to be executed.\r\n     */\r\n    _add(rRoute: RegExp, callback: RouteCallback) {\r\n        this._handlers.push({ route: rRoute, callback: callback });\r\n    }\r\n\r\n    /**\r\n     * Save a fragment into the hash history, or replace the URL state if the\r\n     * 'replace' option is passed. You are responsible for properly URL-encoding\r\n     * the fragment in advance.\r\n     * The options object can contain `trigger: true` if you wish to have the\r\n     * route callback be fired (not usually desirable), or `replace: true`, if\r\n     * you wish to modify the current URL without adding an entry to the history.\r\n     * @param {string} fragment Fragment to navigate to\r\n     * @param {any=} message The message.\r\n     * @param {NavigationOptions=} options Options object.\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     */\r\n    navigate(fragment: string, message?: any, options: NavigationOptions = {}): boolean {\r\n\r\n        if (!History._started) {\r\n            return false;\r\n        }\r\n\r\n        // Normalize the fragment.\r\n        const resource = this.obtainFragment(fragment);\r\n\r\n        this._fragment = resource;\r\n\r\n        // Don't include a trailing slash on the root.\r\n        let rootAux = this._root;\r\n\r\n        if (resource.path === '') {\r\n            rootAux = rootAux.slice(0, -1) || '/';\r\n        }\r\n\r\n        let full = resource.full;\r\n\r\n        const url = rootAux + full;\r\n\r\n        // Strip the hash.\r\n        full = full.replace(HASH_STRIPPER, '');\r\n\r\n        // If pushState is available, we use it to set the fragment as a real URL.\r\n        if (this._usePushState) {\r\n            this._history[options.replace ? 'replaceState' : 'pushState'](null, null, url);\r\n            // If hash changes haven't been explicitly disabled, update the hash\r\n            // fragment to store history.\r\n        } else if (this._wantsHashChange) {\r\n            this._updateHash(full, options.replace);\r\n            // If you've told us that you explicitly don't want fallback hashchange-\r\n            // based history, then `navigate` becomes a page refresh.\r\n        } else {\r\n            return this._location.assign(url);\r\n        }\r\n\r\n        if (options.trigger !== false) {\r\n            return this._loadUrl(full, message);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Delegates to `_loadUrl`.\r\n     * @returns {boolean} true if loaded, false otherwise.\r\n     * @private\r\n     */\r\n    private _checkUrl(): boolean {\r\n        return this._loadUrl();\r\n    }\r\n\r\n    /**\r\n     * Attempt to load the current URL fragment. If a route succeeds with a\r\n     * match, returns `true`. If no defined routes matches the fragment,\r\n     * returns `false`.\r\n     * @param {string} fragment E.g.: 'user/pepito'\r\n     * @param {any} message E.g.: {msg: 'Password changed', type: 'success'}\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     * @private\r\n     */\r\n    private _loadUrl(fragment?: string, message?: any): boolean {\r\n        this._fragment = this.obtainFragment(fragment);\r\n        const handlersLength = this._handlers.length;\r\n        for (let i = 0; i < handlersLength; i++) {\r\n            const handler = this._handlers[i];\r\n            if (handler.route.test(this._fragment.path)) {\r\n                handler.callback(this._fragment, message);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Update the hash location, either replacing the current entry, or adding\r\n     * a new one to the browser history.\r\n     * @param {string} fragment URL fragment\r\n     * @param {boolean} replace flag\r\n     * @private\r\n     */\r\n    private _updateHash(fragment: string, replace?: boolean) {\r\n        if (replace) {\r\n            const href = this._location.href.replace(/(javascript:|#).*$/, '');\r\n            this._location.replace(href + '#' + fragment);\r\n        } else {\r\n            // Some browsers require that `hash` contains a leading #.\r\n            this._location.hash = '#' + fragment;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nexport class Router {\r\n\r\n    // The history object.\r\n    static history: History;\r\n    // The previous route data.\r\n    private _oldRouteData: NavigationData;\r\n    // Copy event bus functionality.\r\n    /* tslint:disable:no-unused-variable */\r\n    private _eventHandlers: EventHandler = {};\r\n    /* tslint:enable:no-unused-variable */\r\n    trigger = History.prototype.trigger;\r\n    on = History.prototype.on;\r\n    off = History.prototype.off;\r\n\r\n    /**\r\n     * Constructor for the router.\r\n     * Routers map faux-URLs to actions, and fire events when routes are\r\n     * matched. Creating a new one sets its `routes` hash, if not set statically.\r\n     * @param {Object|Array} options options.root is a string indicating the site's context, defaults to '/'.\r\n     * @constructor\r\n     */\r\n    constructor(options: any = {}) {\r\n        this._bindHandlers(isArray(options) ? options : options.map);\r\n    }\r\n\r\n    /**\r\n     * Bind all defined routes to `Router.history`. We have to reverse the\r\n     * order of the routes here to support behavior where the most general\r\n     * routes can be defined at the bottom of the route map.\r\n     * @param {RouteHandler[]} handlers list of handlers.\r\n     * @private\r\n     */\r\n    private _bindHandlers(handlers: Handler[]) {\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < handlers.length; i++) {\r\n            this.add(handlers[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Manually bind a single route to a callback.\r\n     * @param {Handler} handler The handler entry.\r\n     * @returns {Router} this router\r\n     */\r\n    add(handler: Handler): Router {\r\n\r\n        const rRoute = RouteHelper.stringToRegexp(handler.route);\r\n\r\n        Router.history._add(rRoute, (resource, message) => {\r\n\r\n            const params = Router._extractParameters(rRoute, resource.path);\r\n\r\n            const newRouteData: NavigationData = { path: resource.path, query: resource.query, params, message, handler };\r\n\r\n            let next = Router.history.trigger('route:before', this, newRouteData, this._oldRouteData);\r\n\r\n            if (next === false) {\r\n                return;\r\n            }\r\n\r\n            next = this.trigger('route:before', newRouteData, this._oldRouteData);\r\n\r\n            if (next === false) {\r\n                return;\r\n            }\r\n\r\n            if (this._oldRouteData && this._oldRouteData.handler.deactivate) {\r\n                next = this._oldRouteData.handler.deactivate.call(this._oldRouteData.handler, newRouteData, this._oldRouteData);\r\n                if (next === false) {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            handler.activate.call(handler, newRouteData, this._oldRouteData);\r\n            Router.history.trigger('route:after', this, newRouteData, this._oldRouteData);\r\n\r\n            this._oldRouteData = newRouteData;\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Given a route, and a path that it matches, return the object of\r\n     * extracted decoded parameters.\r\n     * @param {RegExp} route The alias\r\n     * @param {string} path The uri's path part.\r\n     * @returns {NavigationParams} the extracted parameters\r\n     * @private\r\n     */\r\n    private static _extractParameters(route: RegExp, path: string): NavigationParams {\r\n        const params: NavigationParams = {};\r\n        const result = route.exec(path);\r\n        if (!result) {\r\n            return params;\r\n        }\r\n        const args = result.slice(1);\r\n        const keys = (<any>route).keys;\r\n        for (let i = 0; i < args.length; i++) {\r\n            params[keys[i].name] = _global.decodeURIComponent(args[i]);\r\n        }\r\n        return params;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Create the default Router.History.\r\n * @type {History}\r\n */\r\nRouter.history = new History();\r\n","/**\r\n * Unobtrusive, forward-thinking and lightweight JavaScript router library.\r\n */\r\nvar _global = (typeof self === 'object' && self.self === self && self) ||\r\n    (typeof global === 'object' && global.global === global && global);\r\nvar Resource = (function () {\r\n    function Resource(path, query) {\r\n        this.path = path;\r\n        this.query = query;\r\n        this._full = this.path;\r\n        if (this.query !== undefined && this.query !== null && this.query !== '') {\r\n            this._full += '?' + this.query;\r\n        }\r\n    }\r\n    Object.defineProperty(Resource.prototype, \"full\", {\r\n        get: function () {\r\n            return this._full;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Resource;\r\n})();\r\nexports.Resource = Resource;\r\nvar PATH_STRIPPER = new RegExp([\r\n    '(\\\\\\\\.)',\r\n    '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\r\n].join('|'), 'g');\r\nvar ROUTE_STRIPPER = /^[#\\/]|\\s+$/g;\r\nvar HASH_STRIPPER = /#.*$/;\r\nvar isArray = Array.isArray || function (obj) {\r\n    return Object.prototype.toString.call(obj) === '[object Array]';\r\n};\r\nvar RouteHelper = (function () {\r\n    function RouteHelper() {\r\n    }\r\n    RouteHelper._escapeString = function (str) {\r\n        return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1');\r\n    };\r\n    RouteHelper._escapeGroup = function (group) {\r\n        return group.replace(/([=!:$\\/()])/g, '\\\\$1');\r\n    };\r\n    RouteHelper._flags = function (opts) {\r\n        return opts['sensitive'] ? '' : 'i';\r\n    };\r\n    RouteHelper.parseQuery = function (queryString) {\r\n        var query = {};\r\n        var params = queryString.split('&');\r\n        for (var i = 0; i < params.length; i++) {\r\n            var pair = params[i].split('=');\r\n            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\r\n        }\r\n        return query;\r\n    };\r\n    RouteHelper.parseFragment = function (fragment) {\r\n        if (fragment === '') {\r\n            return new Resource(fragment);\r\n        }\r\n        var qsPos = fragment.indexOf('?');\r\n        var path;\r\n        var query;\r\n        fragment = RouteHelper.decodeFragment(fragment).replace(ROUTE_STRIPPER, '');\r\n        if (qsPos >= 0) {\r\n            path = fragment.slice(0, qsPos);\r\n            query = fragment.slice(qsPos + 1);\r\n        }\r\n        else {\r\n            path = fragment;\r\n        }\r\n        return new Resource(path, query);\r\n    };\r\n    RouteHelper.decodeFragment = function (fragment) {\r\n        fragment = fragment.replace(/%25/g, '%2525');\r\n        return _global.decodeURI(fragment);\r\n    };\r\n    RouteHelper._parse = function (str) {\r\n        var tokens = [];\r\n        var key = 0;\r\n        var index = 0;\r\n        var path = '';\r\n        var res;\r\n        while ((res = PATH_STRIPPER.exec(str))) {\r\n            var m = res[0];\r\n            var escaped = res[1];\r\n            var offset = res.index;\r\n            path += str.slice(index, offset);\r\n            index = offset + m.length;\r\n            if (escaped) {\r\n                path += escaped[1];\r\n                continue;\r\n            }\r\n            if (path) {\r\n                tokens.push(path);\r\n                path = '';\r\n            }\r\n            var prefix = res[2];\r\n            var name_1 = res[3];\r\n            var capture = res[4];\r\n            var group = res[5];\r\n            var suffix = res[6];\r\n            var asterisk = res[7];\r\n            var repeat = suffix === '+' || suffix === '*';\r\n            var optional = suffix === '?' || suffix === '*';\r\n            var delimiter = prefix || '/';\r\n            var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');\r\n            tokens.push({\r\n                name: name_1 || key++,\r\n                prefix: prefix || '',\r\n                delimiter: delimiter,\r\n                optional: optional,\r\n                repeat: repeat,\r\n                pattern: RouteHelper._escapeGroup(pattern)\r\n            });\r\n        }\r\n        if (index < str.length) {\r\n            path += str.substr(index);\r\n        }\r\n        if (path) {\r\n            tokens.push(path);\r\n        }\r\n        return tokens;\r\n    };\r\n    RouteHelper._tokensToRegExp = function (tokens, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var strict = options['strict'];\r\n        var end = options['end'] !== false;\r\n        var route = '';\r\n        var lastToken = tokens[tokens.length - 1];\r\n        var endsWithSlash = typeof lastToken === 'string' && lastToken.length && lastToken.charAt(lastToken.length - 1) === '/';\r\n        for (var i = 0; i < tokens.length; i++) {\r\n            var token = tokens[i];\r\n            if (typeof token === 'string') {\r\n                route += RouteHelper._escapeString(token);\r\n            }\r\n            else {\r\n                var prefix = RouteHelper._escapeString(token.prefix);\r\n                var capture = token.pattern;\r\n                if (token.repeat) {\r\n                    capture += '(?:' + prefix + capture + ')*';\r\n                }\r\n                if (token.optional) {\r\n                    if (prefix) {\r\n                        capture = '(?:' + prefix + '(' + capture + '))?';\r\n                    }\r\n                    else {\r\n                        capture = '(' + capture + ')?';\r\n                    }\r\n                }\r\n                else {\r\n                    capture = prefix + '(' + capture + ')';\r\n                }\r\n                route += capture;\r\n            }\r\n        }\r\n        if (!strict) {\r\n            route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?';\r\n        }\r\n        if (end) {\r\n            route += '$';\r\n        }\r\n        else {\r\n            route += strict && endsWithSlash ? '' : '(?=\\\\/|$)';\r\n        }\r\n        return new RegExp('^' + route, RouteHelper._flags(options));\r\n    };\r\n    RouteHelper.stringToRegexp = function (path, keys, options) {\r\n        if (keys === void 0) { keys = []; }\r\n        var tokens = RouteHelper._parse(path);\r\n        var re = RouteHelper._tokensToRegExp(tokens, options);\r\n        for (var i = 0; i < tokens.length; i++) {\r\n            if (typeof tokens[i] !== 'string') {\r\n                keys.push(tokens[i]);\r\n            }\r\n        }\r\n        re['keys'] = keys;\r\n        return re;\r\n    };\r\n    return RouteHelper;\r\n})();\r\nvar History = (function () {\r\n    function History() {\r\n        this._location = _global.location;\r\n        this._history = _global.history;\r\n        this._handlers = [];\r\n        this._eventHandlers = {};\r\n        this._checkUrl = this._checkUrl.bind(this);\r\n    }\r\n    History.prototype.on = function (evt, callback) {\r\n        if (this._eventHandlers[evt] === undefined) {\r\n            this._eventHandlers[evt] = [];\r\n        }\r\n        this._eventHandlers[evt].push(callback);\r\n        return this;\r\n    };\r\n    History.prototype.off = function (evt, callback) {\r\n        if (this._eventHandlers[evt]) {\r\n            var callbacks = this._eventHandlers[evt];\r\n            for (var i = 0; i < callbacks.length; i++) {\r\n                if (callbacks[i] === callback) {\r\n                    callbacks.splice(i, 1);\r\n                    if (callbacks.length === 0) {\r\n                        delete this._eventHandlers[evt];\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    History.prototype.trigger = function (evt) {\r\n        var restParams = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            restParams[_i - 1] = arguments[_i];\r\n        }\r\n        var callbacks = this._eventHandlers[evt];\r\n        if (callbacks === undefined || !callbacks.length) {\r\n            return null;\r\n        }\r\n        for (var i = 0; i < callbacks.length; i++) {\r\n            var respIt = callbacks[i].apply(this, restParams);\r\n            if (respIt === false) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    History.prototype.isAtRoot = function () {\r\n        var path = this._location.pathname.replace(/[^\\/]$/, '$&/');\r\n        return path === this._root && !this._location.search;\r\n    };\r\n    History.prototype.getCurrentPath = function () {\r\n        var path = RouteHelper.decodeFragment(this._location.pathname).slice(this._root.length - 1);\r\n        if (path.charAt(0) === '/') {\r\n            path = path.slice(1);\r\n        }\r\n        var query = _global.decodeURIComponent(this._location.search.slice(1));\r\n        var full = path;\r\n        if (query) {\r\n            full += '?' + query;\r\n        }\r\n        return new Resource(path, query);\r\n    };\r\n    History.prototype.getCurrentHash = function () {\r\n        var match = this._location.href.match(/#(.*)$/);\r\n        var path = match ? match[1] : '';\r\n        return RouteHelper.parseFragment(path);\r\n    };\r\n    History.prototype.obtainFragment = function (fragment) {\r\n        if (fragment === undefined || fragment === null) {\r\n            if (this._usePushState || !this._wantsHashChange) {\r\n                return this.getCurrentPath();\r\n            }\r\n            return this.getCurrentHash();\r\n        }\r\n        return RouteHelper.parseFragment(fragment);\r\n    };\r\n    History.prototype.start = function (options) {\r\n        if (options === void 0) { options = {}; }\r\n        if (History._started) {\r\n            throw new Error('Router.history has already been started');\r\n        }\r\n        History._started = true;\r\n        this._root = options.root || '/';\r\n        this._wantsHashChange = options.hashChange !== false;\r\n        this._wantsPushState = !!options.pushState;\r\n        this._hasPushState = !!(this._history && this._history.pushState);\r\n        this._usePushState = this._wantsPushState && this._hasPushState;\r\n        this._fragment = this.obtainFragment();\r\n        this._root = ('/' + this._root + '/').replace(/^\\/{2,}|\\/{2,}$/g, '/');\r\n        if (this._wantsHashChange && this._wantsPushState) {\r\n            var isAtRoot = this.isAtRoot();\r\n            if (!this._hasPushState && !isAtRoot) {\r\n                var rootAux = this._root.slice(0, -1) || '/';\r\n                this._location.replace(rootAux + '#' + this.getCurrentPath().full);\r\n                return true;\r\n            }\r\n            else if (this._hasPushState && isAtRoot) {\r\n                this.navigate(this.getCurrentHash().full, null, { replace: true, trigger: false });\r\n            }\r\n        }\r\n        if (this._usePushState) {\r\n            _global.addEventListener('popstate', this._checkUrl, false);\r\n        }\r\n        else if (this._wantsHashChange) {\r\n            _global.addEventListener('hashchange', this._checkUrl, false);\r\n        }\r\n        if (!options.silent) {\r\n            return this._loadUrl();\r\n        }\r\n        return false;\r\n    };\r\n    History.prototype.stop = function () {\r\n        _global.removeEventListener('popstate', this._checkUrl, false);\r\n        _global.removeEventListener('hashchange', this._checkUrl, false);\r\n        History._started = false;\r\n    };\r\n    History.prototype._add = function (rRoute, callback) {\r\n        this._handlers.push({ route: rRoute, callback: callback });\r\n    };\r\n    History.prototype.navigate = function (fragment, message, options) {\r\n        if (options === void 0) { options = {}; }\r\n        if (!History._started) {\r\n            return false;\r\n        }\r\n        var resource = this.obtainFragment(fragment);\r\n        this._fragment = resource;\r\n        var rootAux = this._root;\r\n        if (resource.path === '') {\r\n            rootAux = rootAux.slice(0, -1) || '/';\r\n        }\r\n        var full = resource.full;\r\n        var url = rootAux + full;\r\n        full = full.replace(HASH_STRIPPER, '');\r\n        if (this._usePushState) {\r\n            this._history[options.replace ? 'replaceState' : 'pushState'](null, null, url);\r\n        }\r\n        else if (this._wantsHashChange) {\r\n            this._updateHash(full, options.replace);\r\n        }\r\n        else {\r\n            return this._location.assign(url);\r\n        }\r\n        if (options.trigger !== false) {\r\n            return this._loadUrl(full, message);\r\n        }\r\n        return false;\r\n    };\r\n    History.prototype._checkUrl = function () {\r\n        return this._loadUrl();\r\n    };\r\n    History.prototype._loadUrl = function (fragment, message) {\r\n        this._fragment = this.obtainFragment(fragment);\r\n        var handlersLength = this._handlers.length;\r\n        for (var i = 0; i < handlersLength; i++) {\r\n            var handler = this._handlers[i];\r\n            if (handler.route.test(this._fragment.path)) {\r\n                handler.callback(this._fragment, message);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    History.prototype._updateHash = function (fragment, replace) {\r\n        if (replace) {\r\n            var href = this._location.href.replace(/(javascript:|#).*$/, '');\r\n            this._location.replace(href + '#' + fragment);\r\n        }\r\n        else {\r\n            this._location.hash = '#' + fragment;\r\n        }\r\n    };\r\n    History._started = false;\r\n    return History;\r\n})();\r\nexports.History = History;\r\nvar Router = (function () {\r\n    function Router(options) {\r\n        if (options === void 0) { options = {}; }\r\n        this._eventHandlers = {};\r\n        this.trigger = History.prototype.trigger;\r\n        this.on = History.prototype.on;\r\n        this.off = History.prototype.off;\r\n        this._bindHandlers(isArray(options) ? options : options.map);\r\n    }\r\n    Router.prototype._bindHandlers = function (handlers) {\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < handlers.length; i++) {\r\n            this.add(handlers[i]);\r\n        }\r\n    };\r\n    Router.prototype.add = function (handler) {\r\n        var _this = this;\r\n        var rRoute = RouteHelper.stringToRegexp(handler.route);\r\n        Router.history._add(rRoute, function (resource, message) {\r\n            var params = Router._extractParameters(rRoute, resource.path);\r\n            var newRouteData = { path: resource.path, query: resource.query, params: params, message: message, handler: handler };\r\n            var next = Router.history.trigger('route:before', _this, newRouteData, _this._oldRouteData);\r\n            if (next === false) {\r\n                return;\r\n            }\r\n            next = _this.trigger('route:before', newRouteData, _this._oldRouteData);\r\n            if (next === false) {\r\n                return;\r\n            }\r\n            if (_this._oldRouteData && _this._oldRouteData.handler.deactivate) {\r\n                next = _this._oldRouteData.handler.deactivate.call(_this._oldRouteData.handler, newRouteData, _this._oldRouteData);\r\n                if (next === false) {\r\n                    return;\r\n                }\r\n            }\r\n            handler.activate.call(handler, newRouteData, _this._oldRouteData);\r\n            Router.history.trigger('route:after', _this, newRouteData, _this._oldRouteData);\r\n            _this._oldRouteData = newRouteData;\r\n        });\r\n        return this;\r\n    };\r\n    Router._extractParameters = function (route, path) {\r\n        var params = {};\r\n        var result = route.exec(path);\r\n        if (!result) {\r\n            return params;\r\n        }\r\n        var args = result.slice(1);\r\n        var keys = route.keys;\r\n        for (var i = 0; i < args.length; i++) {\r\n            params[keys[i].name] = _global.decodeURIComponent(args[i]);\r\n        }\r\n        return params;\r\n    };\r\n    return Router;\r\n})();\r\nexports.Router = Router;\r\nRouter.history = new History();\r\n"],"sourceRoot":"/source/"}