{"version":3,"sources":["easy-router.js"],"names":[],"mappings":"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","file":"easy-router.js","sourcesContent":["/**\r\n * Unobtrusive and ultra-lightweight router library 100% compatible with the Backbone.Router's style for declaring routes,\r\n * while providing the following advantages:\r\n * - Unobtrusive, it is designed from the beginning to be integrated with other libraries / frameworks (also vanilla).\r\n * - Great performance, only native functions are used.\r\n * - Small footprint, 5kb for minified version.\r\n * - No dependencies, no jQuery, no Underscore... zero dependencies.\r\n * - Supports both routes' styles, hash and the pushState of History API.\r\n * - Proper JSDoc used in the source code.\r\n * - Works with normal script include and as well in CommonJS style.\r\n *\r\n * ¿Want to create a modern hibrid-app or a website using something like React, Web Components, Handlebars, vanilla JS, etc.?\r\n * ¿Have an existing Backbone project and want to migrate to a more modern framework?\r\n * Good news, EasyRouter will integrates perfectly with all of those!\r\n */\r\n\r\n/**\r\n * EasyRouter provides methods for routing client-side pages, and connecting them to actions.\r\n *\r\n * During page load, after your application has finished creating all of its routers,\r\n * be sure to call start() on the router instance to let know him you have already\r\n * finished the routing setup.\r\n */\r\n\r\n// Cached regular expressions for matching named param parts and splatted\r\n// parts of route strings.\r\nconst optionalParam = /\\((.*?)\\)/g;\r\nconst namedParam = /(\\(\\?)?:\\w+/g;\r\nconst splatParam = /\\*\\w+/g;\r\nconst escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\n\r\nclass EasyRouter {\r\n\r\n    /**\r\n     * Constructor for the router.\r\n     * Routers map faux-URLs to actions, and fire events when routes are\r\n     * matched. Creating a new one sets its `routes` hash, if not set statically.\r\n     * @param {Object} options options.root is a string indicating the site's context, defaults to '/'.\r\n     * @constructor\r\n     */\r\n    constructor(options = {}) {\r\n        this.evtHandlers = {};\r\n        if (options.routes) {\r\n            this.routes = options.routes;\r\n        }\r\n        this._bindRoutes();\r\n        this.initialize.apply(this, arguments);\r\n    }\r\n\r\n    /**\r\n     * Initialize is an empty function by default. Override it with your own\r\n     * initialization logic.\r\n     */\r\n    initialize() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Events listening.\r\n     * @param {string} evt Name of the event for listen to.\r\n     * @param {Function} callback Method to be executed when event triggers.\r\n     * @returns {EasyRouter} this\r\n     */\r\n    on(evt, callback) {\r\n        if (this.evtHandlers[evt] === undefined) {\r\n            this.evtHandlers[evt] = [];\r\n        }\r\n        this.evtHandlers[evt].push(callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Events triggering.\r\n     * @param {string} evt Name of the event being triggered.\r\n     * @returns {boolean} if the event was listened or not.\r\n     */\r\n    trigger(evt) {\r\n        const callbacks = this.evtHandlers[evt];\r\n        if (callbacks === undefined) {\r\n            return false;\r\n        }\r\n        const args = Array.prototype.slice.call(arguments, 1);\r\n        let i = 0;\r\n        const callbacksLength = callbacks.length;\r\n        const respArr = [];\r\n        let resp;\r\n        for (; i < callbacksLength; i++) {\r\n            resp = callbacks[i].apply(this, args);\r\n            respArr.push(resp);\r\n        }\r\n        for (; i < callbacksLength; i++) {\r\n            if (respArr[i] === false) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Manually bind a single named route to a callback.\r\n     * The route argument may be a routing string or regular expression, each matching capture\r\n     * from the route or regular expression will be passed as an argument to the onCallback.\r\n     * @param {string|RegExp} route The route\r\n     * @param {string|Function} name If string, alias for the entry; if Function, behaves like 'onCallback'.\r\n     * @param {Function} onCallback function to call when the new fragment match a route.\r\n     * @returns {EasyRouter} this\r\n     */\r\n    route(route, name, onCallback) {\r\n        const routeAux = (Object.prototype.toString.call(route) === '[object RegExp]') ? route :\r\n            EasyRouter._routeToRegExp(route);\r\n        if (Object.prototype.toString.call(name) === '[object Function]') {\r\n            onCallback = name;\r\n            name = '';\r\n        }\r\n        if (!onCallback) {\r\n            onCallback = this[name];\r\n        }\r\n        const self = this;\r\n        EasyRouter.history.route(routeAux, function (fragment) {\r\n            const args = EasyRouter._extractParameters(routeAux, fragment);\r\n            self.execute(onCallback, args);\r\n            self.trigger.apply(self, ['route:' + name].concat(args));\r\n            self.trigger('route', name, args);\r\n            EasyRouter.history.trigger('route', self, name, args);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Execute a route handler with the provided parameters.  This is an\r\n     * excellent place to do pre-route setup or post-route cleanup.\r\n     * @param {Function} callback The method to execute.\r\n     * @param {Array} args The parameters to pass to the method.\r\n     */\r\n    execute(callback, args) {\r\n        if (callback) {\r\n            callback.apply(this, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple proxy to `EasyRouter.history` to save a fragment into the history.\r\n     * @param {string} fragment Route to navigate to.\r\n     * @param {Object} options parameters\r\n     * @returns {EasyRouter} this\r\n     */\r\n    navigate(fragment, options) {\r\n        EasyRouter.history.navigate(fragment, options);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bind all defined routes to `EasyRouter.history`. We have to reverse the\r\n     * order of the routes here to support behavior where the most general\r\n     * routes can be defined at the bottom of the route map.\r\n     * @private\r\n     */\r\n    _bindRoutes() {\r\n        if (!this.routes) {\r\n            return;\r\n        }\r\n        const routes = Object.keys(this.routes).reverse();\r\n        for (let route of routes) {\r\n            this.route(route, this.routes[route]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a route string into a regular expression, suitable for matching\r\n     * against the current location fragment.\r\n     * @param {string} route The route\r\n     * @returns {RegExp} the obtained regex\r\n     * @private\r\n     */\r\n    static _routeToRegExp(route) {\r\n        const routeAux = route.replace(escapeRegExp, '\\\\$&')\r\n            .replace(optionalParam, '(?:$1)?')\r\n            .replace(namedParam, function (match, optional) {\r\n                return optional ? match : '([^/?]+)';\r\n            })\r\n            .replace(splatParam, '([^?]*?)');\r\n        return new RegExp('^' + routeAux + '(?:\\\\?([\\\\s\\\\S]*))?$');\r\n    }\r\n\r\n    /**\r\n     * Given a route, and a URL fragment that it matches, return the array of\r\n     * extracted decoded parameters. Empty or unmatched parameters will be\r\n     * treated as `null` to normalize cross-browser behavior.\r\n     * @param {RegExp} route The alias\r\n     * @param {string} fragment The url part\r\n     * @returns {Array} the extracted parameters\r\n     * @private\r\n     */\r\n    static _extractParameters(route, fragment) {\r\n        const params = route.exec(fragment).slice(1);\r\n        return params.map(function (param, i) {\r\n            // Don't decode the search params.\r\n            if (i === params.length - 1) {\r\n                return param || null;\r\n            }\r\n            return param ? decodeURIComponent(param) : null;\r\n        });\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Handles cross-browser history management, based on either\r\n * [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n * [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n * and URL fragments.\r\n * @constructor\r\n */\r\n\r\n// Cached regex for stripping a leading hash/slash and trailing space.\r\nconst routeStripper = /^[#\\/]|\\s+$/g;\r\n\r\n// Cached regex for stripping leading and trailing slashes.\r\nconst rootStripper = /^\\/+|\\/+$/g;\r\n\r\n// Cached regex for removing a trailing slash.\r\nconst trailingSlash = /\\/$/;\r\n\r\n// Cached regex for stripping urls of hash.\r\nconst pathStripper = /#.*$/;\r\n\r\nclass History {\r\n\r\n    constructor() {\r\n        // Has the history handling already been started?\r\n        this.started = false;\r\n        this.checkUrl = this.checkUrl.bind(this);\r\n        this.handlers = [];\r\n        this.evtHandlers = {};\r\n        // Ensure that `History` can be used outside of the browser.\r\n        if (typeof root !== 'undefined') {\r\n            this.location = global.location;\r\n            this.history = global.history;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Are we at the app root?\r\n     * @returns {boolean} if we are in the root.\r\n     */\r\n    atRoot() {\r\n        return this.location.pathname.replace(/[^\\/]$/, '$&/') === this.root;\r\n    }\r\n\r\n    /**\r\n     * Gets the true hash value. Cannot use location.hash directly due to bug\r\n     * in Firefox where location.hash will always be decoded.\r\n     * @param {Window} window The window object.\r\n     * @returns {string} The hash.\r\n     */\r\n    static getHash(window) {\r\n        const match = (window || this).location.href.match(/#(.*)$/);\r\n        return match ? match[1] : '';\r\n    }\r\n\r\n    /**\r\n     * Get the cross-browser normalized URL fragment, either from the URL,\r\n     * the hash, or the override.\r\n     * @param {string} fragment The url fragment\r\n     * @param {boolean} forcePushState flag to force the usage of pushSate\r\n     * @returns {string} The fragment.\r\n     */\r\n    getFragment(fragment, forcePushState) {\r\n        if (fragment === undefined) {\r\n            if (this._hasPushState || !this._wantsHashChange || forcePushState) {\r\n                fragment = decodeURI(this.location.pathname + this.location.search);\r\n                const rootUrl = this.root.replace(trailingSlash, '');\r\n                if (!fragment.indexOf(rootUrl)) {\r\n                    fragment = fragment.slice(rootUrl.length);\r\n                }\r\n            } else {\r\n                fragment = this.getHash();\r\n            }\r\n        }\r\n        return fragment.replace(routeStripper, '');\r\n    }\r\n\r\n    /**\r\n     * Start the route change handling, returning `true` if the current URL matches\r\n     * an existing route, and `false` otherwise.\r\n     * @param {Object} options Options\r\n     * @returns {boolean} true if the current fragment matched some handler, false otherwise.\r\n     */\r\n    start(options) {\r\n\r\n        if (History.started) {\r\n            throw new Error('EasyRouter.history has already been started');\r\n        }\r\n\r\n        History.started = true;\r\n\r\n        // Figure out the initial configuration. Is pushState desired ... is it available?\r\n        this.options = options || {};\r\n        this.options.root = options.root || '/';\r\n        this.root = this.options.root;\r\n        this._wantsHashChange = this.options.hashChange !== false;\r\n        this._wantsPushState = !!this.options.pushState;\r\n        this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);\r\n\r\n        // Determine if we need to change the base url, for a pushState link\r\n        // opened by a non-pushState browser.\r\n        this.fragment = this.getFragment();\r\n\r\n        // Normalize root to always include a leading and trailing slash.\r\n        this.root = ('/' + this.root + '/').replace(rootStripper, '/');\r\n\r\n        // Depending on whether we're using pushState or hashes, and whether\r\n        // 'onhashchange' is supported, determine how we check the URL state.\r\n        if (this._hasPushState) {\r\n            global.addEventListener('popstate', this.checkUrl);\r\n        } else if (this._wantsHashChange && ('onhashchange' in global)) {\r\n            global.addEventListener('hashchange', this.checkUrl);\r\n        }\r\n\r\n        const loc = this.location;\r\n\r\n        // Transition from hashChange to pushState or vice versa if both are\r\n        // requested.\r\n        if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n            // If we've started off with a route from a `pushState`-enabled\r\n            // browser, but we're currently in a browser that doesn't support it...\r\n            if (!this._hasPushState && !this.atRoot()) {\r\n                this.fragment = this.getFragment(null, true);\r\n                this.location.replace(this.root + '#' + this.fragment);\r\n                // Return immediately as browser will do redirect to new url\r\n                return true;\r\n                // Or if we've started out with a hash-based route, but we're currently\r\n                // in a browser where it could be `pushState`-based instead...\r\n            } else if (this._hasPushState && this.atRoot() && loc.hash) {\r\n                this.fragment = this.getHash().replace(routeStripper, '');\r\n                this.history.replaceState({}, document.title, this.root + this.fragment);\r\n            }\r\n\r\n        }\r\n\r\n        if (!this.options.silent) {\r\n            return this.loadUrl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable EasyRouter.history, perhaps temporarily. Not useful in a real app,\r\n     * but possibly useful for unit testing Routers.\r\n     */\r\n    stop() {\r\n        global.removeEventListener('popstate', this.checkUrl);\r\n        global.removeEventListener('hashchange', this.checkUrl);\r\n        History.started = false;\r\n    }\r\n\r\n    /**\r\n     * Add a route to be tested when the fragment changes. Routes added later\r\n     * may override previous routes.\r\n     * @param {string} route The route.\r\n     * @param {Function} callback Method to be executed.\r\n     */\r\n    route(route, callback) {\r\n        this.handlers.unshift({route: route, callback: callback});\r\n    }\r\n\r\n    /**\r\n     * Checks the current URL to see if it has changed, and if it has,\r\n     * calls `loadUrl`.\r\n     * @returns {boolean} true if navigated, false otherwise.\r\n     */\r\n    checkUrl() {\r\n        const current = this.getFragment();\r\n        if (current === this.fragment) {\r\n            return false;\r\n        }\r\n        this.loadUrl();\r\n    }\r\n\r\n    /**\r\n     * Attempt to load the current URL fragment. If a route succeeds with a\r\n     * match, returns `true`. If no defined routes matches the fragment,\r\n     * returns `false`.\r\n     * @param {string} fragment E.g.: 'user/pepito'\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     */\r\n    loadUrl(fragment) {\r\n        const fragmentAux = this.fragment = this.getFragment(fragment);\r\n        const n = this.handlers.length;\r\n        let handler;\r\n        for (let i = 0; i < n; i++) {\r\n            handler = this.handlers[i];\r\n            if (handler.route.test(fragmentAux)) {\r\n                handler.callback(fragmentAux);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Save a fragment into the hash history, or replace the URL state if the\r\n     * 'replace' option is passed. You are responsible for properly URL-encoding\r\n     * the fragment in advance.\r\n     *\r\n     * The options object can contain `trigger: true` if you wish to have the\r\n     * route callback be fired (not usually desirable), or `replace: true`, if\r\n     * you wish to modify the current URL without adding an entry to the history.\r\n     * @param {string} fragment Fragment to navigate to\r\n     * @param {Object} options Options object\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     */\r\n    navigate(fragment, options) {\r\n\r\n        if (!History.started) {\r\n            return false;\r\n        }\r\n\r\n        if (!options || options === true) {\r\n            options = {trigger: !!options};\r\n        }\r\n\r\n        let fragmentAux = this.getFragment(fragment || '');\r\n\r\n        // Strip the hash for matching.\r\n        fragmentAux = fragmentAux.replace(pathStripper, '');\r\n\r\n        let url = this.root + fragmentAux;\r\n\r\n        if (this.fragment === fragmentAux) {\r\n            return false;\r\n        }\r\n\r\n        this.fragment = fragmentAux;\r\n\r\n        // Don't include a trailing slash on the root.\r\n        if (fragmentAux === '' && url !== '/') {\r\n            url = url.slice(0, -1);\r\n        }\r\n\r\n        // If pushState is available, we use it to set the fragment as a real URL.\r\n        if (this._hasPushState) {\r\n            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n            // If hash changes haven't been explicitly disabled, update the hash\r\n            // fragment to store history.\r\n        } else if (this._wantsHashChange) {\r\n            History._updateHash(this.location, fragmentAux, options.replace);\r\n            // If you've told us that you explicitly don't want fallback hashchange-\r\n            // based history, then `navigate` becomes a page refresh.\r\n        } else {\r\n            return this.location.assign(url);\r\n        }\r\n        if (options.trigger) {\r\n            return this.loadUrl(fragmentAux);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Update the hash location, either replacing the current entry, or adding\r\n     * a new one to the browser history.\r\n     * @param {Location} location The Location object\r\n     * @param {string} fragment URL fragment\r\n     * @param {boolean} replace flag\r\n     * @private\r\n     */\r\n    static _updateHash(location, fragment, replace) {\r\n        if (replace) {\r\n            const href = location.href.replace(/(javascript:|#).*$/, '');\r\n            location.replace(href + '#' + fragment);\r\n        } else {\r\n            // Some browsers require that `hash` contains a leading #.\r\n            location.hash = '#' + fragment;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Copy event bus listeners.\r\n */\r\nHistory.prototype.trigger = EasyRouter.prototype.trigger;\r\nHistory.prototype.on = EasyRouter.prototype.on;\r\n\r\n\r\n/**\r\n * Create the default EasyRouter.history.\r\n * @type {History}\r\n */\r\nEasyRouter.history = new History();\r\n\r\n\r\nexport {EasyRouter};\r\n"],"sourceRoot":"/source/"}