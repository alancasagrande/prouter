{"version":3,"sources":["easy-router.js"],"names":[],"mappings":"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","file":"easy-router.js","sourcesContent":["/**\r\n * Unobtrusive and ultra-lightweight router library 100% compatible with the Backbone.Router's style for declaring routes,\r\n * while providing the following advantages:\r\n * - Unobtrusive, it is designed from the beginning to be integrated with other libraries / frameworks (also vanilla).\r\n * - Great performance, only native functions are used.\r\n * - Small footprint, 5kb for minified version.\r\n * - No dependencies, no jQuery, no Underscore... zero dependencies.\r\n * - Supports both routes' styles, hash and the pushState of History API.\r\n * - Proper JSDoc used in the source code.\r\n * - Works with normal script include and as well in CommonJS style.\r\n * - Written in [ESNext](https://babeljs.io/) for the future and transpiled to ES5 with UMD format for right now.\r\n *\r\n * ¿Want to create a modern hibrid-app or a website using something like React, Web Components, Handlebars, vanilla JS, etc.?\r\n * ¿Have an existing Backbone project and want to migrate to a more modern framework?\r\n * Good news, EasyRouter will integrates perfectly with all of those!\r\n */\r\n\r\n/**\r\n * EasyRouter provides methods for routing client-side pages, and connecting them to actions.\r\n *\r\n * During page load, after your application has finished creating all of its routers,\r\n * be sure to call start() on the router instance to let know him you have already\r\n * finished the routing setup.\r\n */\r\n\r\nconst root = typeof global === 'undefined' ? window : global;\r\nconst document = root.document;\r\n\r\n// Cached regular expressions for matching named param parts and splatted\r\n// parts of route strings.\r\nconst optionalParam = /\\((.*?)\\)/g;\r\nconst namedParam = /(\\(\\?)?:\\w+/g;\r\nconst splatParam = /\\*\\w+/g;\r\nconst escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\r\nconst trueHash = /#(.*)$/;\r\nconst isRoot = /[^\\/]$/;\r\n\r\n// Cached regex for stripping a leading hash/slash and trailing space.\r\nconst routeStripper = /^[#\\/]|\\s+$/g;\r\n// Cached regex for stripping leading and trailing slashes.\r\nconst rootStripper = /^\\/+|\\/+$/g;\r\n// Cached regex for removing a trailing slash.\r\nconst trailingSlash = /\\/$/;\r\n// Cached regex for stripping urls of hash.\r\nconst pathStripper = /#.*$/;\r\n\r\n\r\n/**\r\n * Handles cross-browser history management, based on either\r\n * [pushState](http://diveintohtml5.info/history.html) and real URLs, or\r\n * [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)\r\n * and URL fragments.\r\n * @constructor\r\n */\r\n\r\nclass History {\r\n\r\n    constructor() {\r\n        // Has the history handling already been started?\r\n        this._started = false;\r\n        this._checkUrl = this._checkUrl.bind(this);\r\n        this._handlers = [];\r\n        this._evtHandlers = {};\r\n        this._location = root.location;\r\n        this._history = root.history;\r\n    }\r\n\r\n    /**\r\n     * Are we at the app root?\r\n     * @returns {boolean} if we are in the root.\r\n     */\r\n    atRoot() {\r\n        return this._location.pathname.replace(isRoot, '$&/') === this._root;\r\n    }\r\n\r\n    /**\r\n     * Gets the true hash value. Cannot use location.hash directly due to bug\r\n     * in Firefox where location.hash will always be decoded.\r\n     * @returns {string} The hash.\r\n     */\r\n    getHash() {\r\n        const match = this._location.href.match(trueHash);\r\n        return match ? match[1] : '';\r\n    }\r\n\r\n    /**\r\n     * Get the cross-browser normalized URL fragment, either from the URL,\r\n     * the hash, or the override.\r\n     * @param {string} fragment The url fragment\r\n     * @param {boolean} forcePushState flag to force the usage of pushSate\r\n     * @returns {string} The fragment.\r\n     */\r\n    getFragment(fragment, forcePushState) {\r\n        let fragmentAux = fragment;\r\n        if (fragmentAux === undefined || fragmentAux === null) {\r\n            if (this._hasPushState || !this._wantsHashChange || forcePushState) {\r\n                fragmentAux = root.decodeURI(this._location.pathname + this._location.search);\r\n                const rootUrl = this._root.replace(trailingSlash, '');\r\n                if (fragmentAux.lastIndexOf(rootUrl, 0) === 0) {\r\n                    fragmentAux = fragmentAux.slice(rootUrl.length);\r\n                }\r\n            } else {\r\n                fragmentAux = this.getHash();\r\n            }\r\n        } else {\r\n            fragmentAux = root.decodeURI(fragmentAux);\r\n        }\r\n        return fragmentAux.replace(routeStripper, '');\r\n    }\r\n\r\n    /**\r\n     * Start the route change handling, returning `true` if the current URL matches\r\n     * an existing route, and `false` otherwise.\r\n     * @param {Object} options Options\r\n     * @returns {boolean} true if the current fragment matched some handler, false otherwise.\r\n     */\r\n    start(options = {}) {\r\n\r\n        if (History._started) {\r\n            throw new Error('Router.history has already been started');\r\n        }\r\n\r\n        History._started = true;\r\n\r\n        // Figure out the initial configuration. Is pushState desired ... is it available?\r\n        this._opts = options;\r\n        this._opts.root = this._opts.root || '/';\r\n        this._root = this._opts.root;\r\n        this._wantsHashChange = this._opts.hashChange !== false;\r\n        this._wantsPushState = !!this._opts.pushState;\r\n        this._hasPushState = !!(this._opts.pushState && this._history && this._history.pushState);\r\n        const fragment = this.getFragment();\r\n\r\n        // Normalize root to always include a leading and trailing slash.\r\n        this._root = ('/' + this._root + '/').replace(rootStripper, '/');\r\n\r\n        // Depending on whether we're using pushState or hashes, and whether\r\n        // 'onhashchange' is supported, determine how we check the URL state.\r\n        if (this._hasPushState) {\r\n            root.addEventListener('popstate', this._checkUrl);\r\n        } else if (this._wantsHashChange && ('onhashchange' in root)) {\r\n            root.addEventListener('hashchange', this._checkUrl);\r\n        }\r\n\r\n        // Determine if we need to change the base url, for a pushState link\r\n        // opened by a non-pushState browser.\r\n        this._fragment = fragment;\r\n\r\n        // Transition from hashChange to pushState or vice versa if both are\r\n        // requested.\r\n        if (this._wantsHashChange && this._wantsPushState) {\r\n\r\n            // If we've started off with a route from a `pushState`-enabled\r\n            // browser, but we're currently in a browser that doesn't support it...\r\n            if (!this._hasPushState && !this.atRoot()) {\r\n                this._fragment = this.getFragment(null, true);\r\n                this._location.replace(this._root + '#' + this._fragment);\r\n                // Return immediately as browser will do redirect to new url\r\n                return true;\r\n                // Or if we've started out with a hash-based route, but we're currently\r\n                // in a browser where it could be `pushState`-based instead...\r\n            } else if (this._hasPushState && this.atRoot() && this._location.hash) {\r\n                this._fragment = this.getHash().replace(routeStripper, '');\r\n                this._history.replaceState({}, document.title, this._root + this._fragment);\r\n            }\r\n\r\n        }\r\n\r\n        if (!this._opts.silent) {\r\n            return this._loadUrl();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable Router.history, perhaps temporarily. Not useful in a real app,\r\n     * but possibly useful for unit testing Routers.\r\n     */\r\n    stop() {\r\n        root.removeEventListener('popstate', this._checkUrl);\r\n        root.removeEventListener('hashchange', this._checkUrl);\r\n        History._started = false;\r\n    }\r\n\r\n    /**\r\n     * Add a route to be tested when the fragment changes. Routes added later\r\n     * may override previous routes.\r\n     * @param {string} routeExp The route.\r\n     * @param {Function} callback Method to be executed.\r\n     * @private\r\n     */\r\n    _addHandler(routeExp, callback) {\r\n        this._handlers.unshift({route: routeExp, callback: callback});\r\n    }\r\n\r\n    /**\r\n     * Checks the current URL to see if it has changed, and if it has,\r\n     * calls `loadUrl`.\r\n     * @returns {boolean} true if navigated, false otherwise.\r\n     * @private\r\n     */\r\n    _checkUrl() {\r\n        const fragment = this.getFragment();\r\n        if (fragment === this._fragment) {\r\n            return false;\r\n        }\r\n        this._loadUrl();\r\n    }\r\n\r\n    /**\r\n     * Attempt to load the current URL fragment. If a route succeeds with a\r\n     * match, returns `true`. If no defined routes matches the fragment,\r\n     * returns `false`.\r\n     * @param {string} fragment E.g.: 'user/pepito'\r\n     * @param {Object} message E.g.: {msg: 'Password changed'}\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     * @private\r\n     */\r\n    _loadUrl(fragment, message) {\r\n        this._fragment = this.getFragment(fragment);\r\n        const n = this._handlers.length;\r\n        let handler;\r\n        for (let i = 0; i < n; i++) {\r\n            handler = this._handlers[i];\r\n            if (handler.route.test(this._fragment)) {\r\n                handler.callback(this._fragment, message);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Save a fragment into the hash history, or replace the URL state if the\r\n     * 'replace' option is passed. You are responsible for properly URL-encoding\r\n     * the fragment in advance.\r\n     *\r\n     * The options object can contain `trigger: true` if you wish to have the\r\n     * route callback be fired (not usually desirable), or `replace: true`, if\r\n     * you wish to modify the current URL without adding an entry to the history.\r\n     * @param {string} fragment Fragment to navigate to\r\n     * @param {Object=} message custom parameters to pass to the handler.\r\n     * @param {Object=} options Options object.\r\n     * @returns {boolean} true if the fragment matched some handler, false otherwise.\r\n     */\r\n    navigate(fragment, message, options) {\r\n\r\n        if (!History._started) {\r\n            return false;\r\n        }\r\n\r\n        const optionsAux = options === undefined ? {trigger: true} : options;\r\n\r\n        let fragmentAux = this.getFragment(fragment || '');\r\n\r\n        let url = this._root + fragmentAux;\r\n\r\n        // Strip the hash for matching.\r\n        fragmentAux = fragmentAux.replace(pathStripper, '');\r\n\r\n        if (this._fragment === fragmentAux) {\r\n            return false;\r\n        }\r\n\r\n        this._fragment = fragmentAux;\r\n\r\n        // Don't include a trailing slash on the root.\r\n        if (fragmentAux === '' && url !== '/') {\r\n            url = url.slice(0, -1);\r\n        }\r\n\r\n        // If pushState is available, we use it to set the fragment as a real URL.\r\n        if (this._hasPushState) {\r\n            this._history[optionsAux.replace ? 'replaceState' : 'pushState']({}, document.title, url);\r\n            // If hash changes haven't been explicitly disabled, update the hash\r\n            // fragment to store history.\r\n        } else if (this._wantsHashChange) {\r\n            this._updateHash(fragmentAux, optionsAux.replace);\r\n            // If you've told us that you explicitly don't want fallback hashchange-\r\n            // based history, then `navigate` becomes a page refresh.\r\n        } else {\r\n            return this._location.assign(url);\r\n        }\r\n\r\n        if (optionsAux.trigger) {\r\n            return this._loadUrl(fragmentAux, message);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add event listener.\r\n     * @param {string} evt Name of the event.\r\n     * @param {Function} callback Method.\r\n     * @returns {History} this history\r\n     */\r\n    on(evt, callback) {\r\n        if (this._evtHandlers[evt] === undefined) {\r\n            this._evtHandlers[evt] = [];\r\n        }\r\n        this._evtHandlers[evt].push(callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove event listener.\r\n     * @param {string} evt Name of the event.\r\n     * @param {Function} callback Method.\r\n     * @returns {History} this history\r\n     */\r\n    off(evt, callback) {\r\n        if (this._evtHandlers[evt]) {\r\n            const callbacks = this._evtHandlers[evt];\r\n            const n = callbacks.length;\r\n            for (let i = 0; i < n; i++) {\r\n                if (callbacks[i] === callback) {\r\n                    callbacks.splice(i, 1);\r\n                    if (callbacks.length === 0) {\r\n                        delete this._evtHandlers[evt];\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Events triggering.\r\n     * @param {string} evt Name of the event being triggered.\r\n     * @private\r\n     */\r\n    _trigger(evt) {\r\n        const callbacks = this._evtHandlers[evt];\r\n        if (callbacks === undefined) {\r\n            return;\r\n        }\r\n        const args = Array.prototype.slice.call(arguments, 1);\r\n        let i = 0;\r\n        const callbacksLength = callbacks.length;\r\n        for (; i < callbacksLength; i++) {\r\n            callbacks[i].apply(this, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the hash location, either replacing the current entry, or adding\r\n     * a new one to the browser history.\r\n     * @param {string} fragment URL fragment\r\n     * @param {boolean} replace flag\r\n     * @private\r\n     */\r\n    _updateHash(fragment, replace) {\r\n        if (replace) {\r\n            const href = this._location.href.replace(/(javascript:|#).*$/, '');\r\n            this._location.replace(href + '#' + fragment);\r\n        } else {\r\n            // Some browsers require that `hash` contains a leading #.\r\n            this._location.hash = '#' + fragment;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Router {\r\n\r\n    /**\r\n     * Constructor for the router.\r\n     * Routers map faux-URLs to actions, and fire events when routes are\r\n     * matched. Creating a new one sets its `routes` hash, if not set statically.\r\n     * @param {Object} options options.root is a string indicating the site's context, defaults to '/'.\r\n     * @constructor\r\n     */\r\n    constructor(options = {}) {\r\n        this._evtHandlers = {};\r\n        this._opts = options;\r\n        this._bindHandlers();\r\n    }\r\n\r\n    /**\r\n     * Manually bind a single named route to a callback.\r\n     * The route argument may be a routing string or regular expression, each matching capture\r\n     * from the route or regular expression will be passed as an argument to the onCallback.\r\n     * @param {Object} handler The handler entry.\r\n     * @returns {Router} this router\r\n     */\r\n    addHandler(handler) {\r\n\r\n        const routeAux = Router._routeToRegExp(handler.route);\r\n        const self = this;\r\n\r\n        Router.history._addHandler(routeAux, function (fragment, args) {\r\n\r\n            const params = Router._extractParameters(routeAux, fragment);\r\n\r\n            if (args) {\r\n                params.push(args);\r\n            }\r\n\r\n            const evtRoute = {new: {fragment: fragment, params: params}};\r\n\r\n            if (self._oldCtrl) {\r\n                evtRoute.old = {fragment: self._oldCtrl.fragment, params: self._oldCtrl.params};\r\n            }\r\n\r\n            self._trigger('route:before', evtRoute);\r\n            Router.history._trigger('route:before', self, evtRoute);\r\n\r\n            if (evtRoute.canceled) {\r\n                return;\r\n            }\r\n\r\n            if (self._oldCtrl && self._oldCtrl.off) {\r\n                self._oldCtrl.off.apply(self._oldCtrl);\r\n            }\r\n\r\n            handler.on.apply(handler, params);\r\n\r\n            self._trigger('route:after', evtRoute);\r\n            Router.history._trigger('route:after', self, evtRoute);\r\n\r\n            self._oldCtrl = {off: handler.off, fragment: fragment, params: params};\r\n        });\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Simple proxy to `Router.history` to save a fragment into the history.\r\n     * @param {string} fragment Route to navigate to.\r\n     * @param {Object=} message custom parameters to pass to the handler.\r\n     * @param {Object} options parameters\r\n     * @returns {Router} this router\r\n     */\r\n    navigate(fragment, message, options) {\r\n        Router.history.navigate(fragment, message, options);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Bind all defined routes to `Router.history`. We have to reverse the\r\n     * order of the routes here to support behavior where the most general\r\n     * routes can be defined at the bottom of the route map.\r\n     * @private\r\n     */\r\n    _bindHandlers() {\r\n        if (!this._opts.map) {\r\n            return;\r\n        }\r\n        const routes = this._opts.map;\r\n        const routesN = routes.length - 1;\r\n        for (let i = routesN; i >= 0; i--) {\r\n            this.addHandler(routes[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a route string into a regular expression, suitable for matching\r\n     * against the current location fragment.\r\n     * @param {string} route The route\r\n     * @returns {RegExp} the obtained regex\r\n     * @private\r\n     */\r\n    static _routeToRegExp(route) {\r\n        const routeAux = route.replace(escapeRegExp, '\\\\$&')\r\n            .replace(optionalParam, '(?:$1)?')\r\n            .replace(namedParam, function (match, optional) {\r\n                return optional ? match : '([^/?]+)';\r\n            })\r\n            .replace(splatParam, '([^?]*?)');\r\n        return new RegExp('^' + routeAux + '(?:\\\\?([\\\\s\\\\S]*))?$');\r\n    }\r\n\r\n    /**\r\n     * Given a route, and a URL fragment that it matches, return the array of\r\n     * extracted decoded parameters. Empty or unmatched parameters will be\r\n     * treated as `null` to normalize cross-browser behavior.\r\n     * @param {RegExp} route The alias\r\n     * @param {string} fragment The url part\r\n     * @returns {Array} the extracted parameters\r\n     * @private\r\n     */\r\n    static _extractParameters(route, fragment) {\r\n        const params = route.exec(fragment).slice(1);\r\n        const paramsLength = params.length;\r\n        const args = [];\r\n        for (let i = 0, param; i < paramsLength; i++) {\r\n            param = params[i];\r\n            // Don't decode the search params.\r\n            if (i === params.length - 1 && param) {\r\n                args.push(param || null);\r\n            } else if (param) {\r\n                args.push(root.decodeURIComponent(param));\r\n            }\r\n        }\r\n        return args;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Copy event bus listeners.\r\n */\r\nRouter.prototype._trigger = History.prototype._trigger;\r\nRouter.prototype.on = History.prototype.on;\r\nRouter.prototype.off = History.prototype.off;\r\n\r\n/**\r\n * Create the default Router.History.\r\n * @type {History}\r\n */\r\nRouter.history = new History();\r\n\r\n\r\nexport {History, Router};\r\n"],"sourceRoot":"/source/"}